// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_net_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_net_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_net_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_net_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
class Announce;
struct AnnounceDefaultTypeInternal;
extern AnnounceDefaultTypeInternal _Announce_default_instance_;
class Announce_Other_Peers;
struct Announce_Other_PeersDefaultTypeInternal;
extern Announce_Other_PeersDefaultTypeInternal _Announce_Other_Peers_default_instance_;
class Auth_Ticket;
struct Auth_TicketDefaultTypeInternal;
extern Auth_TicketDefaultTypeInternal _Auth_Ticket_default_instance_;
class Common_Message;
struct Common_MessageDefaultTypeInternal;
extern Common_MessageDefaultTypeInternal _Common_Message_default_instance_;
class Friend;
struct FriendDefaultTypeInternal;
extern FriendDefaultTypeInternal _Friend_default_instance_;
class Friend_Messages;
struct Friend_MessagesDefaultTypeInternal;
extern Friend_MessagesDefaultTypeInternal _Friend_Messages_default_instance_;
class Friend_RichPresenceEntry_DoNotUse;
struct Friend_RichPresenceEntry_DoNotUseDefaultTypeInternal;
extern Friend_RichPresenceEntry_DoNotUseDefaultTypeInternal _Friend_RichPresenceEntry_DoNotUse_default_instance_;
class Gameserver;
struct GameserverDefaultTypeInternal;
extern GameserverDefaultTypeInternal _Gameserver_default_instance_;
class Gameserver_ValuesEntry_DoNotUse;
struct Gameserver_ValuesEntry_DoNotUseDefaultTypeInternal;
extern Gameserver_ValuesEntry_DoNotUseDefaultTypeInternal _Gameserver_ValuesEntry_DoNotUse_default_instance_;
class Lobby;
struct LobbyDefaultTypeInternal;
extern LobbyDefaultTypeInternal _Lobby_default_instance_;
class Lobby_Gameserver;
struct Lobby_GameserverDefaultTypeInternal;
extern Lobby_GameserverDefaultTypeInternal _Lobby_Gameserver_default_instance_;
class Lobby_Member;
struct Lobby_MemberDefaultTypeInternal;
extern Lobby_MemberDefaultTypeInternal _Lobby_Member_default_instance_;
class Lobby_Member_ValuesEntry_DoNotUse;
struct Lobby_Member_ValuesEntry_DoNotUseDefaultTypeInternal;
extern Lobby_Member_ValuesEntry_DoNotUseDefaultTypeInternal _Lobby_Member_ValuesEntry_DoNotUse_default_instance_;
class Lobby_Messages;
struct Lobby_MessagesDefaultTypeInternal;
extern Lobby_MessagesDefaultTypeInternal _Lobby_Messages_default_instance_;
class Lobby_Messages_MapEntry_DoNotUse;
struct Lobby_Messages_MapEntry_DoNotUseDefaultTypeInternal;
extern Lobby_Messages_MapEntry_DoNotUseDefaultTypeInternal _Lobby_Messages_MapEntry_DoNotUse_default_instance_;
class Lobby_ValuesEntry_DoNotUse;
struct Lobby_ValuesEntry_DoNotUseDefaultTypeInternal;
extern Lobby_ValuesEntry_DoNotUseDefaultTypeInternal _Lobby_ValuesEntry_DoNotUse_default_instance_;
class Low_Level;
struct Low_LevelDefaultTypeInternal;
extern Low_LevelDefaultTypeInternal _Low_Level_default_instance_;
class Network;
struct NetworkDefaultTypeInternal;
extern NetworkDefaultTypeInternal _Network_default_instance_;
class Network_Old;
struct Network_OldDefaultTypeInternal;
extern Network_OldDefaultTypeInternal _Network_Old_default_instance_;
class Networking_Sockets;
struct Networking_SocketsDefaultTypeInternal;
extern Networking_SocketsDefaultTypeInternal _Networking_Sockets_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Announce* Arena::CreateMaybeMessage<::Announce>(Arena*);
template<> ::Announce_Other_Peers* Arena::CreateMaybeMessage<::Announce_Other_Peers>(Arena*);
template<> ::Auth_Ticket* Arena::CreateMaybeMessage<::Auth_Ticket>(Arena*);
template<> ::Common_Message* Arena::CreateMaybeMessage<::Common_Message>(Arena*);
template<> ::Friend* Arena::CreateMaybeMessage<::Friend>(Arena*);
template<> ::Friend_Messages* Arena::CreateMaybeMessage<::Friend_Messages>(Arena*);
template<> ::Friend_RichPresenceEntry_DoNotUse* Arena::CreateMaybeMessage<::Friend_RichPresenceEntry_DoNotUse>(Arena*);
template<> ::Gameserver* Arena::CreateMaybeMessage<::Gameserver>(Arena*);
template<> ::Gameserver_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::Gameserver_ValuesEntry_DoNotUse>(Arena*);
template<> ::Lobby* Arena::CreateMaybeMessage<::Lobby>(Arena*);
template<> ::Lobby_Gameserver* Arena::CreateMaybeMessage<::Lobby_Gameserver>(Arena*);
template<> ::Lobby_Member* Arena::CreateMaybeMessage<::Lobby_Member>(Arena*);
template<> ::Lobby_Member_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::Lobby_Member_ValuesEntry_DoNotUse>(Arena*);
template<> ::Lobby_Messages* Arena::CreateMaybeMessage<::Lobby_Messages>(Arena*);
template<> ::Lobby_Messages_MapEntry_DoNotUse* Arena::CreateMaybeMessage<::Lobby_Messages_MapEntry_DoNotUse>(Arena*);
template<> ::Lobby_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::Lobby_ValuesEntry_DoNotUse>(Arena*);
template<> ::Low_Level* Arena::CreateMaybeMessage<::Low_Level>(Arena*);
template<> ::Network* Arena::CreateMaybeMessage<::Network>(Arena*);
template<> ::Network_Old* Arena::CreateMaybeMessage<::Network_Old>(Arena*);
template<> ::Networking_Sockets* Arena::CreateMaybeMessage<::Networking_Sockets>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Announce_Types : int {
  Announce_Types_PING = 0,
  Announce_Types_PONG = 1,
  Announce_Types_Announce_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Announce_Types_Announce_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Announce_Types_IsValid(int value);
constexpr Announce_Types Announce_Types_Types_MIN = Announce_Types_PING;
constexpr Announce_Types Announce_Types_Types_MAX = Announce_Types_PONG;
constexpr int Announce_Types_Types_ARRAYSIZE = Announce_Types_Types_MAX + 1;

const std::string& Announce_Types_Name(Announce_Types value);
template<typename T>
inline const std::string& Announce_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Announce_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Announce_Types_Name.");
  return Announce_Types_Name(static_cast<Announce_Types>(enum_t_value));
}
bool Announce_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Announce_Types* value);
enum Lobby_Messages_Types : int {
  Lobby_Messages_Types_JOIN = 0,
  Lobby_Messages_Types_LEAVE = 1,
  Lobby_Messages_Types_CHANGE_OWNER = 2,
  Lobby_Messages_Types_MEMBER_DATA = 3,
  Lobby_Messages_Types_CHAT_MESSAGE = 4,
  Lobby_Messages_Types_Lobby_Messages_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Lobby_Messages_Types_Lobby_Messages_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Lobby_Messages_Types_IsValid(int value);
constexpr Lobby_Messages_Types Lobby_Messages_Types_Types_MIN = Lobby_Messages_Types_JOIN;
constexpr Lobby_Messages_Types Lobby_Messages_Types_Types_MAX = Lobby_Messages_Types_CHAT_MESSAGE;
constexpr int Lobby_Messages_Types_Types_ARRAYSIZE = Lobby_Messages_Types_Types_MAX + 1;

const std::string& Lobby_Messages_Types_Name(Lobby_Messages_Types value);
template<typename T>
inline const std::string& Lobby_Messages_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Lobby_Messages_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Lobby_Messages_Types_Name.");
  return Lobby_Messages_Types_Name(static_cast<Lobby_Messages_Types>(enum_t_value));
}
bool Lobby_Messages_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Lobby_Messages_Types* value);
enum Low_Level_Types : int {
  Low_Level_Types_HEARTBEAT = 0,
  Low_Level_Types_CONNECT = 1,
  Low_Level_Types_DISCONNECT = 2,
  Low_Level_Types_Low_Level_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Low_Level_Types_Low_Level_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Low_Level_Types_IsValid(int value);
constexpr Low_Level_Types Low_Level_Types_Types_MIN = Low_Level_Types_HEARTBEAT;
constexpr Low_Level_Types Low_Level_Types_Types_MAX = Low_Level_Types_DISCONNECT;
constexpr int Low_Level_Types_Types_ARRAYSIZE = Low_Level_Types_Types_MAX + 1;

const std::string& Low_Level_Types_Name(Low_Level_Types value);
template<typename T>
inline const std::string& Low_Level_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Low_Level_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Low_Level_Types_Name.");
  return Low_Level_Types_Name(static_cast<Low_Level_Types>(enum_t_value));
}
bool Low_Level_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Low_Level_Types* value);
enum Network_Types : int {
  Network_Types_DATA = 0,
  Network_Types_NEW_CONNECTION = 1,
  Network_Types_Network_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Network_Types_Network_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Network_Types_IsValid(int value);
constexpr Network_Types Network_Types_Types_MIN = Network_Types_DATA;
constexpr Network_Types Network_Types_Types_MAX = Network_Types_NEW_CONNECTION;
constexpr int Network_Types_Types_ARRAYSIZE = Network_Types_Types_MAX + 1;

const std::string& Network_Types_Name(Network_Types value);
template<typename T>
inline const std::string& Network_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Network_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Network_Types_Name.");
  return Network_Types_Name(static_cast<Network_Types>(enum_t_value));
}
bool Network_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Network_Types* value);
enum Network_Old_Types : int {
  Network_Old_Types_CONNECTION_REQUEST_IP = 0,
  Network_Old_Types_CONNECTION_REQUEST_STEAMID = 1,
  Network_Old_Types_CONNECTION_ACCEPTED = 2,
  Network_Old_Types_CONNECTION_END = 3,
  Network_Old_Types_DATA = 4,
  Network_Old_Types_Network_Old_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Network_Old_Types_Network_Old_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Network_Old_Types_IsValid(int value);
constexpr Network_Old_Types Network_Old_Types_Types_MIN = Network_Old_Types_CONNECTION_REQUEST_IP;
constexpr Network_Old_Types Network_Old_Types_Types_MAX = Network_Old_Types_DATA;
constexpr int Network_Old_Types_Types_ARRAYSIZE = Network_Old_Types_Types_MAX + 1;

const std::string& Network_Old_Types_Name(Network_Old_Types value);
template<typename T>
inline const std::string& Network_Old_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Network_Old_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Network_Old_Types_Name.");
  return Network_Old_Types_Name(static_cast<Network_Old_Types>(enum_t_value));
}
bool Network_Old_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Network_Old_Types* value);
enum Networking_Sockets_Types : int {
  Networking_Sockets_Types_CONNECTION_REQUEST = 0,
  Networking_Sockets_Types_CONNECTION_ACCEPTED = 2,
  Networking_Sockets_Types_CONNECTION_END = 3,
  Networking_Sockets_Types_DATA = 4,
  Networking_Sockets_Types_Networking_Sockets_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Networking_Sockets_Types_Networking_Sockets_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Networking_Sockets_Types_IsValid(int value);
constexpr Networking_Sockets_Types Networking_Sockets_Types_Types_MIN = Networking_Sockets_Types_CONNECTION_REQUEST;
constexpr Networking_Sockets_Types Networking_Sockets_Types_Types_MAX = Networking_Sockets_Types_DATA;
constexpr int Networking_Sockets_Types_Types_ARRAYSIZE = Networking_Sockets_Types_Types_MAX + 1;

const std::string& Networking_Sockets_Types_Name(Networking_Sockets_Types value);
template<typename T>
inline const std::string& Networking_Sockets_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Networking_Sockets_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Networking_Sockets_Types_Name.");
  return Networking_Sockets_Types_Name(static_cast<Networking_Sockets_Types>(enum_t_value));
}
bool Networking_Sockets_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Networking_Sockets_Types* value);
enum Auth_Ticket_Types : int {
  Auth_Ticket_Types_CANCEL = 0,
  Auth_Ticket_Types_Auth_Ticket_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Auth_Ticket_Types_Auth_Ticket_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Auth_Ticket_Types_IsValid(int value);
constexpr Auth_Ticket_Types Auth_Ticket_Types_Types_MIN = Auth_Ticket_Types_CANCEL;
constexpr Auth_Ticket_Types Auth_Ticket_Types_Types_MAX = Auth_Ticket_Types_CANCEL;
constexpr int Auth_Ticket_Types_Types_ARRAYSIZE = Auth_Ticket_Types_Types_MAX + 1;

const std::string& Auth_Ticket_Types_Name(Auth_Ticket_Types value);
template<typename T>
inline const std::string& Auth_Ticket_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Auth_Ticket_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Auth_Ticket_Types_Name.");
  return Auth_Ticket_Types_Name(static_cast<Auth_Ticket_Types>(enum_t_value));
}
bool Auth_Ticket_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Auth_Ticket_Types* value);
enum Friend_Messages_Types : int {
  Friend_Messages_Types_LOBBY_INVITE = 0,
  Friend_Messages_Types_GAME_INVITE = 1,
  Friend_Messages_Types_Friend_Messages_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Friend_Messages_Types_Friend_Messages_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Friend_Messages_Types_IsValid(int value);
constexpr Friend_Messages_Types Friend_Messages_Types_Types_MIN = Friend_Messages_Types_LOBBY_INVITE;
constexpr Friend_Messages_Types Friend_Messages_Types_Types_MAX = Friend_Messages_Types_GAME_INVITE;
constexpr int Friend_Messages_Types_Types_ARRAYSIZE = Friend_Messages_Types_Types_MAX + 1;

const std::string& Friend_Messages_Types_Name(Friend_Messages_Types value);
template<typename T>
inline const std::string& Friend_Messages_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Friend_Messages_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Friend_Messages_Types_Name.");
  return Friend_Messages_Types_Name(static_cast<Friend_Messages_Types>(enum_t_value));
}
bool Friend_Messages_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Friend_Messages_Types* value);
// ===================================================================

class Announce_Other_Peers final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Announce.Other_Peers) */ {
 public:
  inline Announce_Other_Peers() : Announce_Other_Peers(nullptr) {}
  ~Announce_Other_Peers() override;
  explicit constexpr Announce_Other_Peers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Announce_Other_Peers(const Announce_Other_Peers& from);
  Announce_Other_Peers(Announce_Other_Peers&& from) noexcept
    : Announce_Other_Peers() {
    *this = ::std::move(from);
  }

  inline Announce_Other_Peers& operator=(const Announce_Other_Peers& from) {
    CopyFrom(from);
    return *this;
  }
  inline Announce_Other_Peers& operator=(Announce_Other_Peers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Announce_Other_Peers& default_instance() {
    return *internal_default_instance();
  }
  static inline const Announce_Other_Peers* internal_default_instance() {
    return reinterpret_cast<const Announce_Other_Peers*>(
               &_Announce_Other_Peers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Announce_Other_Peers& a, Announce_Other_Peers& b) {
    a.Swap(&b);
  }
  inline void Swap(Announce_Other_Peers* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Announce_Other_Peers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Announce_Other_Peers* New() const final {
    return new Announce_Other_Peers();
  }

  Announce_Other_Peers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Announce_Other_Peers>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Announce_Other_Peers& from);
  void MergeFrom(const Announce_Other_Peers& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Announce_Other_Peers* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Announce.Other_Peers";
  }
  protected:
  explicit Announce_Other_Peers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIpFieldNumber = 2,
    kUdpPortFieldNumber = 3,
    kAppidFieldNumber = 4,
  };
  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 ip = 2;
  void clear_ip();
  ::PROTOBUF_NAMESPACE_ID::uint32 ip() const;
  void set_ip(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ip() const;
  void _internal_set_ip(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 udp_port = 3;
  void clear_udp_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 udp_port() const;
  void set_udp_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_udp_port() const;
  void _internal_set_udp_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 appid = 4;
  void clear_appid();
  ::PROTOBUF_NAMESPACE_ID::uint32 appid() const;
  void set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_appid() const;
  void _internal_set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Announce.Other_Peers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ip_;
  ::PROTOBUF_NAMESPACE_ID::uint32 udp_port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 appid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Announce final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Announce) */ {
 public:
  inline Announce() : Announce(nullptr) {}
  ~Announce() override;
  explicit constexpr Announce(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Announce(const Announce& from);
  Announce(Announce&& from) noexcept
    : Announce() {
    *this = ::std::move(from);
  }

  inline Announce& operator=(const Announce& from) {
    CopyFrom(from);
    return *this;
  }
  inline Announce& operator=(Announce&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Announce& default_instance() {
    return *internal_default_instance();
  }
  static inline const Announce* internal_default_instance() {
    return reinterpret_cast<const Announce*>(
               &_Announce_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Announce& a, Announce& b) {
    a.Swap(&b);
  }
  inline void Swap(Announce* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Announce* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Announce* New() const final {
    return new Announce();
  }

  Announce* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Announce>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Announce& from);
  void MergeFrom(const Announce& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Announce* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Announce";
  }
  protected:
  explicit Announce(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Announce_Other_Peers Other_Peers;

  typedef Announce_Types Types;
  static constexpr Types PING =
    Announce_Types_PING;
  static constexpr Types PONG =
    Announce_Types_PONG;
  static inline bool Types_IsValid(int value) {
    return Announce_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Announce_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Announce_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Announce_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Announce_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Announce_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 2,
    kPeersFieldNumber = 4,
    kTypeFieldNumber = 1,
    kTcpPortFieldNumber = 3,
    kAppidFieldNumber = 5,
  };
  // repeated uint64 ids = 2;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_ids() const;
  void _internal_add_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 ids(int index) const;
  void set_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_ids();

  // repeated .Announce.Other_Peers peers = 4;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::Announce_Other_Peers* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Announce_Other_Peers >*
      mutable_peers();
  private:
  const ::Announce_Other_Peers& _internal_peers(int index) const;
  ::Announce_Other_Peers* _internal_add_peers();
  public:
  const ::Announce_Other_Peers& peers(int index) const;
  ::Announce_Other_Peers* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Announce_Other_Peers >&
      peers() const;

  // .Announce.Types type = 1;
  void clear_type();
  ::Announce_Types type() const;
  void set_type(::Announce_Types value);
  private:
  ::Announce_Types _internal_type() const;
  void _internal_set_type(::Announce_Types value);
  public:

  // uint32 tcp_port = 3;
  void clear_tcp_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 tcp_port() const;
  void set_tcp_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tcp_port() const;
  void _internal_set_tcp_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 appid = 5;
  void clear_appid();
  ::PROTOBUF_NAMESPACE_ID::uint32 appid() const;
  void set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_appid() const;
  void _internal_set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Announce)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > ids_;
  mutable std::atomic<int> _ids_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Announce_Other_Peers > peers_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tcp_port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 appid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Lobby_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Lobby_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Lobby_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  Lobby_ValuesEntry_DoNotUse();
  explicit constexpr Lobby_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Lobby_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Lobby_ValuesEntry_DoNotUse& other);
  static const Lobby_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Lobby_ValuesEntry_DoNotUse*>(&_Lobby_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Lobby.ValuesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Lobby_Member_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Lobby_Member_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Lobby_Member_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  Lobby_Member_ValuesEntry_DoNotUse();
  explicit constexpr Lobby_Member_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Lobby_Member_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Lobby_Member_ValuesEntry_DoNotUse& other);
  static const Lobby_Member_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Lobby_Member_ValuesEntry_DoNotUse*>(&_Lobby_Member_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Lobby.Member.ValuesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Lobby_Member final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Lobby.Member) */ {
 public:
  inline Lobby_Member() : Lobby_Member(nullptr) {}
  ~Lobby_Member() override;
  explicit constexpr Lobby_Member(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lobby_Member(const Lobby_Member& from);
  Lobby_Member(Lobby_Member&& from) noexcept
    : Lobby_Member() {
    *this = ::std::move(from);
  }

  inline Lobby_Member& operator=(const Lobby_Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lobby_Member& operator=(Lobby_Member&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Lobby_Member& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lobby_Member* internal_default_instance() {
    return reinterpret_cast<const Lobby_Member*>(
               &_Lobby_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Lobby_Member& a, Lobby_Member& b) {
    a.Swap(&b);
  }
  inline void Swap(Lobby_Member* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lobby_Member* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lobby_Member* New() const final {
    return new Lobby_Member();
  }

  Lobby_Member* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lobby_Member>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Lobby_Member& from);
  void MergeFrom(const Lobby_Member& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Lobby_Member* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Lobby.Member";
  }
  protected:
  explicit Lobby_Member(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // map<string, bytes> values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_values();

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Lobby.Member)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Lobby_Member_ValuesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> values_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Lobby_Gameserver final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Lobby.Gameserver) */ {
 public:
  inline Lobby_Gameserver() : Lobby_Gameserver(nullptr) {}
  ~Lobby_Gameserver() override;
  explicit constexpr Lobby_Gameserver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lobby_Gameserver(const Lobby_Gameserver& from);
  Lobby_Gameserver(Lobby_Gameserver&& from) noexcept
    : Lobby_Gameserver() {
    *this = ::std::move(from);
  }

  inline Lobby_Gameserver& operator=(const Lobby_Gameserver& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lobby_Gameserver& operator=(Lobby_Gameserver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Lobby_Gameserver& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lobby_Gameserver* internal_default_instance() {
    return reinterpret_cast<const Lobby_Gameserver*>(
               &_Lobby_Gameserver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Lobby_Gameserver& a, Lobby_Gameserver& b) {
    a.Swap(&b);
  }
  inline void Swap(Lobby_Gameserver* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lobby_Gameserver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lobby_Gameserver* New() const final {
    return new Lobby_Gameserver();
  }

  Lobby_Gameserver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lobby_Gameserver>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Lobby_Gameserver& from);
  void MergeFrom(const Lobby_Gameserver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Lobby_Gameserver* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Lobby.Gameserver";
  }
  protected:
  explicit Lobby_Gameserver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIpFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 ip = 2;
  void clear_ip();
  ::PROTOBUF_NAMESPACE_ID::uint32 ip() const;
  void set_ip(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ip() const;
  void _internal_set_ip(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 port = 3;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Lobby.Gameserver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ip_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Lobby final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Lobby) */ {
 public:
  inline Lobby() : Lobby(nullptr) {}
  ~Lobby() override;
  explicit constexpr Lobby(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lobby(const Lobby& from);
  Lobby(Lobby&& from) noexcept
    : Lobby() {
    *this = ::std::move(from);
  }

  inline Lobby& operator=(const Lobby& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lobby& operator=(Lobby&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Lobby& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lobby* internal_default_instance() {
    return reinterpret_cast<const Lobby*>(
               &_Lobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Lobby& a, Lobby& b) {
    a.Swap(&b);
  }
  inline void Swap(Lobby* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lobby* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lobby* New() const final {
    return new Lobby();
  }

  Lobby* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lobby>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Lobby& from);
  void MergeFrom(const Lobby& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Lobby* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Lobby";
  }
  protected:
  explicit Lobby(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Lobby_Member Member;
  typedef Lobby_Gameserver Gameserver;

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 3,
    kMembersFieldNumber = 4,
    kGameserverFieldNumber = 5,
    kRoomIdFieldNumber = 1,
    kOwnerFieldNumber = 2,
    kMemberLimitFieldNumber = 6,
    kTypeFieldNumber = 7,
    kAppidFieldNumber = 9,
    kJoinableFieldNumber = 8,
    kDeletedFieldNumber = 32,
    kTimeDeletedFieldNumber = 33,
  };
  // map<string, bytes> values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_values();

  // repeated .Lobby.Member members = 4;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::Lobby_Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Lobby_Member >*
      mutable_members();
  private:
  const ::Lobby_Member& _internal_members(int index) const;
  ::Lobby_Member* _internal_add_members();
  public:
  const ::Lobby_Member& members(int index) const;
  ::Lobby_Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Lobby_Member >&
      members() const;

  // .Lobby.Gameserver gameserver = 5;
  bool has_gameserver() const;
  private:
  bool _internal_has_gameserver() const;
  public:
  void clear_gameserver();
  const ::Lobby_Gameserver& gameserver() const;
  PROTOBUF_MUST_USE_RESULT ::Lobby_Gameserver* release_gameserver();
  ::Lobby_Gameserver* mutable_gameserver();
  void set_allocated_gameserver(::Lobby_Gameserver* gameserver);
  private:
  const ::Lobby_Gameserver& _internal_gameserver() const;
  ::Lobby_Gameserver* _internal_mutable_gameserver();
  public:
  void unsafe_arena_set_allocated_gameserver(
      ::Lobby_Gameserver* gameserver);
  ::Lobby_Gameserver* unsafe_arena_release_gameserver();

  // uint64 room_id = 1;
  void clear_room_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 room_id() const;
  void set_room_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_room_id() const;
  void _internal_set_room_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 owner = 2;
  void clear_owner();
  ::PROTOBUF_NAMESPACE_ID::uint64 owner() const;
  void set_owner(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_owner() const;
  void _internal_set_owner(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 member_limit = 6;
  void clear_member_limit();
  ::PROTOBUF_NAMESPACE_ID::uint32 member_limit() const;
  void set_member_limit(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_member_limit() const;
  void _internal_set_member_limit(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 type = 7;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 appid = 9;
  void clear_appid();
  ::PROTOBUF_NAMESPACE_ID::uint32 appid() const;
  void set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_appid() const;
  void _internal_set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool joinable = 8;
  void clear_joinable();
  bool joinable() const;
  void set_joinable(bool value);
  private:
  bool _internal_joinable() const;
  void _internal_set_joinable(bool value);
  public:

  // bool deleted = 32;
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // uint64 time_deleted = 33;
  void clear_time_deleted();
  ::PROTOBUF_NAMESPACE_ID::uint64 time_deleted() const;
  void set_time_deleted(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_time_deleted() const;
  void _internal_set_time_deleted(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Lobby)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Lobby_ValuesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Lobby_Member > members_;
  ::Lobby_Gameserver* gameserver_;
  ::PROTOBUF_NAMESPACE_ID::uint64 room_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 owner_;
  ::PROTOBUF_NAMESPACE_ID::uint32 member_limit_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 appid_;
  bool joinable_;
  bool deleted_;
  ::PROTOBUF_NAMESPACE_ID::uint64 time_deleted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Lobby_Messages_MapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Lobby_Messages_MapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Lobby_Messages_MapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  Lobby_Messages_MapEntry_DoNotUse();
  explicit constexpr Lobby_Messages_MapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Lobby_Messages_MapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Lobby_Messages_MapEntry_DoNotUse& other);
  static const Lobby_Messages_MapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Lobby_Messages_MapEntry_DoNotUse*>(&_Lobby_Messages_MapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Lobby_Messages.MapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Lobby_Messages final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Lobby_Messages) */ {
 public:
  inline Lobby_Messages() : Lobby_Messages(nullptr) {}
  ~Lobby_Messages() override;
  explicit constexpr Lobby_Messages(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lobby_Messages(const Lobby_Messages& from);
  Lobby_Messages(Lobby_Messages&& from) noexcept
    : Lobby_Messages() {
    *this = ::std::move(from);
  }

  inline Lobby_Messages& operator=(const Lobby_Messages& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lobby_Messages& operator=(Lobby_Messages&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Lobby_Messages& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lobby_Messages* internal_default_instance() {
    return reinterpret_cast<const Lobby_Messages*>(
               &_Lobby_Messages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Lobby_Messages& a, Lobby_Messages& b) {
    a.Swap(&b);
  }
  inline void Swap(Lobby_Messages* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lobby_Messages* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lobby_Messages* New() const final {
    return new Lobby_Messages();
  }

  Lobby_Messages* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lobby_Messages>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Lobby_Messages& from);
  void MergeFrom(const Lobby_Messages& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Lobby_Messages* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Lobby_Messages";
  }
  protected:
  explicit Lobby_Messages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  typedef Lobby_Messages_Types Types;
  static constexpr Types JOIN =
    Lobby_Messages_Types_JOIN;
  static constexpr Types LEAVE =
    Lobby_Messages_Types_LEAVE;
  static constexpr Types CHANGE_OWNER =
    Lobby_Messages_Types_CHANGE_OWNER;
  static constexpr Types MEMBER_DATA =
    Lobby_Messages_Types_MEMBER_DATA;
  static constexpr Types CHAT_MESSAGE =
    Lobby_Messages_Types_CHAT_MESSAGE;
  static inline bool Types_IsValid(int value) {
    return Lobby_Messages_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Lobby_Messages_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Lobby_Messages_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Lobby_Messages_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Lobby_Messages_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Lobby_Messages_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMapFieldNumber = 5,
    kBdataFieldNumber = 4,
    kIdFieldNumber = 1,
    kIdataFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // map<string, bytes> map = 5;
  int map_size() const;
  private:
  int _internal_map_size() const;
  public:
  void clear_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_map();

  // bytes bdata = 4;
  void clear_bdata();
  const std::string& bdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bdata();
  PROTOBUF_MUST_USE_RESULT std::string* release_bdata();
  void set_allocated_bdata(std::string* bdata);
  private:
  const std::string& _internal_bdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bdata(const std::string& value);
  std::string* _internal_mutable_bdata();
  public:

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 idata = 3;
  void clear_idata();
  ::PROTOBUF_NAMESPACE_ID::uint64 idata() const;
  void set_idata(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_idata() const;
  void _internal_set_idata(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .Lobby_Messages.Types type = 2;
  void clear_type();
  ::Lobby_Messages_Types type() const;
  void set_type(::Lobby_Messages_Types value);
  private:
  ::Lobby_Messages_Types _internal_type() const;
  void _internal_set_type(::Lobby_Messages_Types value);
  public:

  // @@protoc_insertion_point(class_scope:Lobby_Messages)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Lobby_Messages_MapEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> map_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bdata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 idata_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Low_Level final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Low_Level) */ {
 public:
  inline Low_Level() : Low_Level(nullptr) {}
  ~Low_Level() override;
  explicit constexpr Low_Level(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Low_Level(const Low_Level& from);
  Low_Level(Low_Level&& from) noexcept
    : Low_Level() {
    *this = ::std::move(from);
  }

  inline Low_Level& operator=(const Low_Level& from) {
    CopyFrom(from);
    return *this;
  }
  inline Low_Level& operator=(Low_Level&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Low_Level& default_instance() {
    return *internal_default_instance();
  }
  static inline const Low_Level* internal_default_instance() {
    return reinterpret_cast<const Low_Level*>(
               &_Low_Level_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Low_Level& a, Low_Level& b) {
    a.Swap(&b);
  }
  inline void Swap(Low_Level* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Low_Level* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Low_Level* New() const final {
    return new Low_Level();
  }

  Low_Level* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Low_Level>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Low_Level& from);
  void MergeFrom(const Low_Level& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Low_Level* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Low_Level";
  }
  protected:
  explicit Low_Level(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Low_Level_Types Types;
  static constexpr Types HEARTBEAT =
    Low_Level_Types_HEARTBEAT;
  static constexpr Types CONNECT =
    Low_Level_Types_CONNECT;
  static constexpr Types DISCONNECT =
    Low_Level_Types_DISCONNECT;
  static inline bool Types_IsValid(int value) {
    return Low_Level_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Low_Level_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Low_Level_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Low_Level_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Low_Level_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Low_Level_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .Low_Level.Types type = 1;
  void clear_type();
  ::Low_Level_Types type() const;
  void set_type(::Low_Level_Types value);
  private:
  ::Low_Level_Types _internal_type() const;
  void _internal_set_type(::Low_Level_Types value);
  public:

  // @@protoc_insertion_point(class_scope:Low_Level)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Network final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Network) */ {
 public:
  inline Network() : Network(nullptr) {}
  ~Network() override;
  explicit constexpr Network(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Network(const Network& from);
  Network(Network&& from) noexcept
    : Network() {
    *this = ::std::move(from);
  }

  inline Network& operator=(const Network& from) {
    CopyFrom(from);
    return *this;
  }
  inline Network& operator=(Network&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Network& default_instance() {
    return *internal_default_instance();
  }
  static inline const Network* internal_default_instance() {
    return reinterpret_cast<const Network*>(
               &_Network_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Network& a, Network& b) {
    a.Swap(&b);
  }
  inline void Swap(Network* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Network* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Network* New() const final {
    return new Network();
  }

  Network* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Network>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Network& from);
  void MergeFrom(const Network& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Network* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Network";
  }
  protected:
  explicit Network(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Network_Types Types;
  static constexpr Types DATA =
    Network_Types_DATA;
  static constexpr Types NEW_CONNECTION =
    Network_Types_NEW_CONNECTION;
  static inline bool Types_IsValid(int value) {
    return Network_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Network_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Network_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Network_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Network_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Network_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kChannelFieldNumber = 1,
    kTypeFieldNumber = 3,
    kProcessedFieldNumber = 128,
    kTimeProcessedFieldNumber = 129,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint32 channel = 1;
  void clear_channel();
  ::PROTOBUF_NAMESPACE_ID::uint32 channel() const;
  void set_channel(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel() const;
  void _internal_set_channel(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .Network.Types type = 3;
  void clear_type();
  ::Network_Types type() const;
  void set_type(::Network_Types value);
  private:
  ::Network_Types _internal_type() const;
  void _internal_set_type(::Network_Types value);
  public:

  // bool processed = 128;
  void clear_processed();
  bool processed() const;
  void set_processed(bool value);
  private:
  bool _internal_processed() const;
  void _internal_set_processed(bool value);
  public:

  // uint64 time_processed = 129;
  void clear_time_processed();
  ::PROTOBUF_NAMESPACE_ID::uint64 time_processed() const;
  void set_time_processed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_time_processed() const;
  void _internal_set_time_processed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Network)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_;
  int type_;
  bool processed_;
  ::PROTOBUF_NAMESPACE_ID::uint64 time_processed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Network_Old final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Network_Old) */ {
 public:
  inline Network_Old() : Network_Old(nullptr) {}
  ~Network_Old() override;
  explicit constexpr Network_Old(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Network_Old(const Network_Old& from);
  Network_Old(Network_Old&& from) noexcept
    : Network_Old() {
    *this = ::std::move(from);
  }

  inline Network_Old& operator=(const Network_Old& from) {
    CopyFrom(from);
    return *this;
  }
  inline Network_Old& operator=(Network_Old&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Network_Old& default_instance() {
    return *internal_default_instance();
  }
  static inline const Network_Old* internal_default_instance() {
    return reinterpret_cast<const Network_Old*>(
               &_Network_Old_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Network_Old& a, Network_Old& b) {
    a.Swap(&b);
  }
  inline void Swap(Network_Old* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Network_Old* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Network_Old* New() const final {
    return new Network_Old();
  }

  Network_Old* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Network_Old>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Network_Old& from);
  void MergeFrom(const Network_Old& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Network_Old* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Network_Old";
  }
  protected:
  explicit Network_Old(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Network_Old_Types Types;
  static constexpr Types CONNECTION_REQUEST_IP =
    Network_Old_Types_CONNECTION_REQUEST_IP;
  static constexpr Types CONNECTION_REQUEST_STEAMID =
    Network_Old_Types_CONNECTION_REQUEST_STEAMID;
  static constexpr Types CONNECTION_ACCEPTED =
    Network_Old_Types_CONNECTION_ACCEPTED;
  static constexpr Types CONNECTION_END =
    Network_Old_Types_CONNECTION_END;
  static constexpr Types DATA =
    Network_Old_Types_DATA;
  static inline bool Types_IsValid(int value) {
    return Network_Old_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Network_Old_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Network_Old_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Network_Old_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Network_Old_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Network_Old_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kConnectionIdFieldNumber = 2,
    kTypeFieldNumber = 1,
    kPortFieldNumber = 4,
    kConnectionIdFromFieldNumber = 3,
  };
  // bytes data = 5;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 connection_id = 2;
  void clear_connection_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 connection_id() const;
  void set_connection_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_connection_id() const;
  void _internal_set_connection_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .Network_Old.Types type = 1;
  void clear_type();
  ::Network_Old_Types type() const;
  void set_type(::Network_Old_Types value);
  private:
  ::Network_Old_Types _internal_type() const;
  void _internal_set_type(::Network_Old_Types value);
  public:

  // uint32 port = 4;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint64 connection_id_from = 3;
  void clear_connection_id_from();
  ::PROTOBUF_NAMESPACE_ID::uint64 connection_id_from() const;
  void set_connection_id_from(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_connection_id_from() const;
  void _internal_set_connection_id_from(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Network_Old)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::uint64 connection_id_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  ::PROTOBUF_NAMESPACE_ID::uint64 connection_id_from_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Networking_Sockets final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Networking_Sockets) */ {
 public:
  inline Networking_Sockets() : Networking_Sockets(nullptr) {}
  ~Networking_Sockets() override;
  explicit constexpr Networking_Sockets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Networking_Sockets(const Networking_Sockets& from);
  Networking_Sockets(Networking_Sockets&& from) noexcept
    : Networking_Sockets() {
    *this = ::std::move(from);
  }

  inline Networking_Sockets& operator=(const Networking_Sockets& from) {
    CopyFrom(from);
    return *this;
  }
  inline Networking_Sockets& operator=(Networking_Sockets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Networking_Sockets& default_instance() {
    return *internal_default_instance();
  }
  static inline const Networking_Sockets* internal_default_instance() {
    return reinterpret_cast<const Networking_Sockets*>(
               &_Networking_Sockets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Networking_Sockets& a, Networking_Sockets& b) {
    a.Swap(&b);
  }
  inline void Swap(Networking_Sockets* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Networking_Sockets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Networking_Sockets* New() const final {
    return new Networking_Sockets();
  }

  Networking_Sockets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Networking_Sockets>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Networking_Sockets& from);
  void MergeFrom(const Networking_Sockets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Networking_Sockets* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Networking_Sockets";
  }
  protected:
  explicit Networking_Sockets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Networking_Sockets_Types Types;
  static constexpr Types CONNECTION_REQUEST =
    Networking_Sockets_Types_CONNECTION_REQUEST;
  static constexpr Types CONNECTION_ACCEPTED =
    Networking_Sockets_Types_CONNECTION_ACCEPTED;
  static constexpr Types CONNECTION_END =
    Networking_Sockets_Types_CONNECTION_END;
  static constexpr Types DATA =
    Networking_Sockets_Types_DATA;
  static inline bool Types_IsValid(int value) {
    return Networking_Sockets_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Networking_Sockets_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Networking_Sockets_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Networking_Sockets_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Networking_Sockets_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Networking_Sockets_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kTypeFieldNumber = 1,
    kPortFieldNumber = 2,
    kConnectionIdFieldNumber = 3,
    kConnectionIdFromFieldNumber = 4,
  };
  // bytes data = 5;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .Networking_Sockets.Types type = 1;
  void clear_type();
  ::Networking_Sockets_Types type() const;
  void set_type(::Networking_Sockets_Types value);
  private:
  ::Networking_Sockets_Types _internal_type() const;
  void _internal_set_type(::Networking_Sockets_Types value);
  public:

  // uint32 port = 2;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint64 connection_id = 3;
  void clear_connection_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 connection_id() const;
  void set_connection_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_connection_id() const;
  void _internal_set_connection_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 connection_id_from = 4;
  void clear_connection_id_from();
  ::PROTOBUF_NAMESPACE_ID::uint64 connection_id_from() const;
  void set_connection_id_from(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_connection_id_from() const;
  void _internal_set_connection_id_from(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Networking_Sockets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  ::PROTOBUF_NAMESPACE_ID::uint64 connection_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 connection_id_from_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Gameserver_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Gameserver_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Gameserver_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  Gameserver_ValuesEntry_DoNotUse();
  explicit constexpr Gameserver_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Gameserver_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Gameserver_ValuesEntry_DoNotUse& other);
  static const Gameserver_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Gameserver_ValuesEntry_DoNotUse*>(&_Gameserver_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Gameserver.ValuesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Gameserver final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Gameserver) */ {
 public:
  inline Gameserver() : Gameserver(nullptr) {}
  ~Gameserver() override;
  explicit constexpr Gameserver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gameserver(const Gameserver& from);
  Gameserver(Gameserver&& from) noexcept
    : Gameserver() {
    *this = ::std::move(from);
  }

  inline Gameserver& operator=(const Gameserver& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gameserver& operator=(Gameserver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Gameserver& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gameserver* internal_default_instance() {
    return reinterpret_cast<const Gameserver*>(
               &_Gameserver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Gameserver& a, Gameserver& b) {
    a.Swap(&b);
  }
  inline void Swap(Gameserver* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gameserver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Gameserver* New() const final {
    return new Gameserver();
  }

  Gameserver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Gameserver>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Gameserver& from);
  void MergeFrom(const Gameserver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Gameserver* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Gameserver";
  }
  protected:
  explicit Gameserver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 12,
    kGameDescriptionFieldNumber = 2,
    kModDirFieldNumber = 3,
    kServerNameFieldNumber = 7,
    kMapNameFieldNumber = 8,
    kSpectatorServerNameFieldNumber = 11,
    kTagsFieldNumber = 13,
    kGamedataFieldNumber = 14,
    kRegionFieldNumber = 15,
    kProductFieldNumber = 16,
    kIdFieldNumber = 1,
    kMaxPlayerCountFieldNumber = 5,
    kBotPlayerCountFieldNumber = 6,
    kSpectatorPortFieldNumber = 10,
    kNumPlayersFieldNumber = 18,
    kVersionFieldNumber = 19,
    kDedicatedServerFieldNumber = 4,
    kPasswordProtectedFieldNumber = 9,
    kSecureFieldNumber = 17,
    kOfflineFieldNumber = 48,
    kIpFieldNumber = 32,
    kPortFieldNumber = 33,
    kQueryPortFieldNumber = 34,
    kAppidFieldNumber = 35,
  };
  // map<string, bytes> values = 12;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_values();

  // bytes game_description = 2;
  void clear_game_description();
  const std::string& game_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_game_description();
  void set_allocated_game_description(std::string* game_description);
  private:
  const std::string& _internal_game_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_description(const std::string& value);
  std::string* _internal_mutable_game_description();
  public:

  // bytes mod_dir = 3;
  void clear_mod_dir();
  const std::string& mod_dir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mod_dir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mod_dir();
  PROTOBUF_MUST_USE_RESULT std::string* release_mod_dir();
  void set_allocated_mod_dir(std::string* mod_dir);
  private:
  const std::string& _internal_mod_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mod_dir(const std::string& value);
  std::string* _internal_mutable_mod_dir();
  public:

  // bytes server_name = 7;
  void clear_server_name();
  const std::string& server_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_server_name();
  void set_allocated_server_name(std::string* server_name);
  private:
  const std::string& _internal_server_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_name(const std::string& value);
  std::string* _internal_mutable_server_name();
  public:

  // bytes map_name = 8;
  void clear_map_name();
  const std::string& map_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_map_name();
  void set_allocated_map_name(std::string* map_name);
  private:
  const std::string& _internal_map_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_name(const std::string& value);
  std::string* _internal_mutable_map_name();
  public:

  // bytes spectator_server_name = 11;
  void clear_spectator_server_name();
  const std::string& spectator_server_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spectator_server_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spectator_server_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_spectator_server_name();
  void set_allocated_spectator_server_name(std::string* spectator_server_name);
  private:
  const std::string& _internal_spectator_server_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spectator_server_name(const std::string& value);
  std::string* _internal_mutable_spectator_server_name();
  public:

  // bytes tags = 13;
  void clear_tags();
  const std::string& tags() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tags(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tags();
  PROTOBUF_MUST_USE_RESULT std::string* release_tags();
  void set_allocated_tags(std::string* tags);
  private:
  const std::string& _internal_tags() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tags(const std::string& value);
  std::string* _internal_mutable_tags();
  public:

  // bytes gamedata = 14;
  void clear_gamedata();
  const std::string& gamedata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gamedata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gamedata();
  PROTOBUF_MUST_USE_RESULT std::string* release_gamedata();
  void set_allocated_gamedata(std::string* gamedata);
  private:
  const std::string& _internal_gamedata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gamedata(const std::string& value);
  std::string* _internal_mutable_gamedata();
  public:

  // bytes region = 15;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_MUST_USE_RESULT std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // bytes product = 16;
  void clear_product();
  const std::string& product() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product();
  PROTOBUF_MUST_USE_RESULT std::string* release_product();
  void set_allocated_product(std::string* product);
  private:
  const std::string& _internal_product() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product(const std::string& value);
  std::string* _internal_mutable_product();
  public:

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 max_player_count = 5;
  void clear_max_player_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_player_count() const;
  void set_max_player_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_player_count() const;
  void _internal_set_max_player_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 bot_player_count = 6;
  void clear_bot_player_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 bot_player_count() const;
  void set_bot_player_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_bot_player_count() const;
  void _internal_set_bot_player_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 spectator_port = 10;
  void clear_spectator_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 spectator_port() const;
  void set_spectator_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_spectator_port() const;
  void _internal_set_spectator_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 num_players = 18;
  void clear_num_players();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_players() const;
  void set_num_players(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_players() const;
  void _internal_set_num_players(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 version = 19;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool dedicated_server = 4;
  void clear_dedicated_server();
  bool dedicated_server() const;
  void set_dedicated_server(bool value);
  private:
  bool _internal_dedicated_server() const;
  void _internal_set_dedicated_server(bool value);
  public:

  // bool password_protected = 9;
  void clear_password_protected();
  bool password_protected() const;
  void set_password_protected(bool value);
  private:
  bool _internal_password_protected() const;
  void _internal_set_password_protected(bool value);
  public:

  // bool secure = 17;
  void clear_secure();
  bool secure() const;
  void set_secure(bool value);
  private:
  bool _internal_secure() const;
  void _internal_set_secure(bool value);
  public:

  // bool offline = 48;
  void clear_offline();
  bool offline() const;
  void set_offline(bool value);
  private:
  bool _internal_offline() const;
  void _internal_set_offline(bool value);
  public:

  // uint32 ip = 32;
  void clear_ip();
  ::PROTOBUF_NAMESPACE_ID::uint32 ip() const;
  void set_ip(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ip() const;
  void _internal_set_ip(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 port = 33;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 query_port = 34;
  void clear_query_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 query_port() const;
  void set_query_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_query_port() const;
  void _internal_set_query_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 appid = 35;
  void clear_appid();
  ::PROTOBUF_NAMESPACE_ID::uint32 appid() const;
  void set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_appid() const;
  void _internal_set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Gameserver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Gameserver_ValuesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mod_dir_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spectator_server_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamedata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_player_count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bot_player_count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 spectator_port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_players_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  bool dedicated_server_;
  bool password_protected_;
  bool secure_;
  bool offline_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ip_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 query_port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 appid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Friend_RichPresenceEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Friend_RichPresenceEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Friend_RichPresenceEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  Friend_RichPresenceEntry_DoNotUse();
  explicit constexpr Friend_RichPresenceEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Friend_RichPresenceEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Friend_RichPresenceEntry_DoNotUse& other);
  static const Friend_RichPresenceEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Friend_RichPresenceEntry_DoNotUse*>(&_Friend_RichPresenceEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Friend.RichPresenceEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Friend final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Friend) */ {
 public:
  inline Friend() : Friend(nullptr) {}
  ~Friend() override;
  explicit constexpr Friend(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Friend(const Friend& from);
  Friend(Friend&& from) noexcept
    : Friend() {
    *this = ::std::move(from);
  }

  inline Friend& operator=(const Friend& from) {
    CopyFrom(from);
    return *this;
  }
  inline Friend& operator=(Friend&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Friend& default_instance() {
    return *internal_default_instance();
  }
  static inline const Friend* internal_default_instance() {
    return reinterpret_cast<const Friend*>(
               &_Friend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Friend& a, Friend& b) {
    a.Swap(&b);
  }
  inline void Swap(Friend* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Friend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Friend* New() const final {
    return new Friend();
  }

  Friend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Friend>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Friend& from);
  void MergeFrom(const Friend& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Friend* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Friend";
  }
  protected:
  explicit Friend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRichPresenceFieldNumber = 3,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kLobbyIdFieldNumber = 5,
    kAppidFieldNumber = 4,
  };
  // map<string, bytes> rich_presence = 3;
  int rich_presence_size() const;
  private:
  int _internal_rich_presence_size() const;
  public:
  void clear_rich_presence();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_rich_presence() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_rich_presence();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      rich_presence() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_rich_presence();

  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 lobby_id = 5;
  void clear_lobby_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 lobby_id() const;
  void set_lobby_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_lobby_id() const;
  void _internal_set_lobby_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 appid = 4;
  void clear_appid();
  ::PROTOBUF_NAMESPACE_ID::uint32 appid() const;
  void set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_appid() const;
  void _internal_set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Friend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Friend_RichPresenceEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> rich_presence_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 lobby_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 appid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Auth_Ticket final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Auth_Ticket) */ {
 public:
  inline Auth_Ticket() : Auth_Ticket(nullptr) {}
  ~Auth_Ticket() override;
  explicit constexpr Auth_Ticket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Auth_Ticket(const Auth_Ticket& from);
  Auth_Ticket(Auth_Ticket&& from) noexcept
    : Auth_Ticket() {
    *this = ::std::move(from);
  }

  inline Auth_Ticket& operator=(const Auth_Ticket& from) {
    CopyFrom(from);
    return *this;
  }
  inline Auth_Ticket& operator=(Auth_Ticket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Auth_Ticket& default_instance() {
    return *internal_default_instance();
  }
  static inline const Auth_Ticket* internal_default_instance() {
    return reinterpret_cast<const Auth_Ticket*>(
               &_Auth_Ticket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Auth_Ticket& a, Auth_Ticket& b) {
    a.Swap(&b);
  }
  inline void Swap(Auth_Ticket* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Auth_Ticket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Auth_Ticket* New() const final {
    return new Auth_Ticket();
  }

  Auth_Ticket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Auth_Ticket>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Auth_Ticket& from);
  void MergeFrom(const Auth_Ticket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Auth_Ticket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Auth_Ticket";
  }
  protected:
  explicit Auth_Ticket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Auth_Ticket_Types Types;
  static constexpr Types CANCEL =
    Auth_Ticket_Types_CANCEL;
  static inline bool Types_IsValid(int value) {
    return Auth_Ticket_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Auth_Ticket_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Auth_Ticket_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Auth_Ticket_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Auth_Ticket_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Auth_Ticket_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // uint32 number = 1;
  void clear_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 number() const;
  void set_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_number() const;
  void _internal_set_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .Auth_Ticket.Types type = 2;
  void clear_type();
  ::Auth_Ticket_Types type() const;
  void set_type(::Auth_Ticket_Types value);
  private:
  ::Auth_Ticket_Types _internal_type() const;
  void _internal_set_type(::Auth_Ticket_Types value);
  public:

  // @@protoc_insertion_point(class_scope:Auth_Ticket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 number_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Friend_Messages final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Friend_Messages) */ {
 public:
  inline Friend_Messages() : Friend_Messages(nullptr) {}
  ~Friend_Messages() override;
  explicit constexpr Friend_Messages(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Friend_Messages(const Friend_Messages& from);
  Friend_Messages(Friend_Messages&& from) noexcept
    : Friend_Messages() {
    *this = ::std::move(from);
  }

  inline Friend_Messages& operator=(const Friend_Messages& from) {
    CopyFrom(from);
    return *this;
  }
  inline Friend_Messages& operator=(Friend_Messages&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Friend_Messages& default_instance() {
    return *internal_default_instance();
  }
  enum InviteDataCase {
    kLobbyId = 2,
    kConnectStr = 3,
    INVITE_DATA_NOT_SET = 0,
  };

  static inline const Friend_Messages* internal_default_instance() {
    return reinterpret_cast<const Friend_Messages*>(
               &_Friend_Messages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Friend_Messages& a, Friend_Messages& b) {
    a.Swap(&b);
  }
  inline void Swap(Friend_Messages* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Friend_Messages* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Friend_Messages* New() const final {
    return new Friend_Messages();
  }

  Friend_Messages* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Friend_Messages>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Friend_Messages& from);
  void MergeFrom(const Friend_Messages& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Friend_Messages* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Friend_Messages";
  }
  protected:
  explicit Friend_Messages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Friend_Messages_Types Types;
  static constexpr Types LOBBY_INVITE =
    Friend_Messages_Types_LOBBY_INVITE;
  static constexpr Types GAME_INVITE =
    Friend_Messages_Types_GAME_INVITE;
  static inline bool Types_IsValid(int value) {
    return Friend_Messages_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Friend_Messages_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Friend_Messages_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Friend_Messages_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Friend_Messages_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Friend_Messages_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kLobbyIdFieldNumber = 2,
    kConnectStrFieldNumber = 3,
  };
  // .Friend_Messages.Types type = 1;
  void clear_type();
  ::Friend_Messages_Types type() const;
  void set_type(::Friend_Messages_Types value);
  private:
  ::Friend_Messages_Types _internal_type() const;
  void _internal_set_type(::Friend_Messages_Types value);
  public:

  // uint64 lobby_id = 2;
  bool has_lobby_id() const;
  private:
  bool _internal_has_lobby_id() const;
  public:
  void clear_lobby_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 lobby_id() const;
  void set_lobby_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_lobby_id() const;
  void _internal_set_lobby_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bytes connect_str = 3;
  bool has_connect_str() const;
  private:
  bool _internal_has_connect_str() const;
  public:
  void clear_connect_str();
  const std::string& connect_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connect_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connect_str();
  PROTOBUF_MUST_USE_RESULT std::string* release_connect_str();
  void set_allocated_connect_str(std::string* connect_str);
  private:
  const std::string& _internal_connect_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connect_str(const std::string& value);
  std::string* _internal_mutable_connect_str();
  public:

  void clear_invite_data();
  InviteDataCase invite_data_case() const;
  // @@protoc_insertion_point(class_scope:Friend_Messages)
 private:
  class _Internal;
  void set_has_lobby_id();
  void set_has_connect_str();

  inline bool has_invite_data() const;
  inline void clear_has_invite_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  union InviteDataUnion {
    constexpr InviteDataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint64 lobby_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connect_str_;
  } invite_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Common_Message final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Common_Message) */ {
 public:
  inline Common_Message() : Common_Message(nullptr) {}
  ~Common_Message() override;
  explicit constexpr Common_Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Common_Message(const Common_Message& from);
  Common_Message(Common_Message&& from) noexcept
    : Common_Message() {
    *this = ::std::move(from);
  }

  inline Common_Message& operator=(const Common_Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Common_Message& operator=(Common_Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Common_Message& default_instance() {
    return *internal_default_instance();
  }
  enum MessagesCase {
    kAnnounce = 3,
    kLowLevel = 4,
    kLobby = 5,
    kLobbyMessages = 6,
    kNetwork = 7,
    kGameserver = 8,
    kFriend = 9,
    kAuthTicket = 10,
    kFriendMessages = 11,
    kNetworkOld = 12,
    kNetworkingSockets = 13,
    MESSAGES_NOT_SET = 0,
  };

  static inline const Common_Message* internal_default_instance() {
    return reinterpret_cast<const Common_Message*>(
               &_Common_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Common_Message& a, Common_Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Common_Message* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Common_Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Common_Message* New() const final {
    return new Common_Message();
  }

  Common_Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Common_Message>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Common_Message& from);
  void MergeFrom(const Common_Message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Common_Message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common_Message";
  }
  protected:
  explicit Common_Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 1,
    kDestIdFieldNumber = 2,
    kSourceIpFieldNumber = 128,
    kSourcePortFieldNumber = 129,
    kAnnounceFieldNumber = 3,
    kLowLevelFieldNumber = 4,
    kLobbyFieldNumber = 5,
    kLobbyMessagesFieldNumber = 6,
    kNetworkFieldNumber = 7,
    kGameserverFieldNumber = 8,
    kFriendFieldNumber = 9,
    kAuthTicketFieldNumber = 10,
    kFriendMessagesFieldNumber = 11,
    kNetworkOldFieldNumber = 12,
    kNetworkingSocketsFieldNumber = 13,
  };
  // uint64 source_id = 1;
  void clear_source_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 source_id() const;
  void set_source_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_source_id() const;
  void _internal_set_source_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 dest_id = 2;
  void clear_dest_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 dest_id() const;
  void set_dest_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_dest_id() const;
  void _internal_set_dest_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 source_ip = 128;
  void clear_source_ip();
  ::PROTOBUF_NAMESPACE_ID::uint32 source_ip() const;
  void set_source_ip(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_source_ip() const;
  void _internal_set_source_ip(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 source_port = 129;
  void clear_source_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 source_port() const;
  void set_source_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_source_port() const;
  void _internal_set_source_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .Announce announce = 3;
  bool has_announce() const;
  private:
  bool _internal_has_announce() const;
  public:
  void clear_announce();
  const ::Announce& announce() const;
  PROTOBUF_MUST_USE_RESULT ::Announce* release_announce();
  ::Announce* mutable_announce();
  void set_allocated_announce(::Announce* announce);
  private:
  const ::Announce& _internal_announce() const;
  ::Announce* _internal_mutable_announce();
  public:
  void unsafe_arena_set_allocated_announce(
      ::Announce* announce);
  ::Announce* unsafe_arena_release_announce();

  // .Low_Level low_level = 4;
  bool has_low_level() const;
  private:
  bool _internal_has_low_level() const;
  public:
  void clear_low_level();
  const ::Low_Level& low_level() const;
  PROTOBUF_MUST_USE_RESULT ::Low_Level* release_low_level();
  ::Low_Level* mutable_low_level();
  void set_allocated_low_level(::Low_Level* low_level);
  private:
  const ::Low_Level& _internal_low_level() const;
  ::Low_Level* _internal_mutable_low_level();
  public:
  void unsafe_arena_set_allocated_low_level(
      ::Low_Level* low_level);
  ::Low_Level* unsafe_arena_release_low_level();

  // .Lobby lobby = 5;
  bool has_lobby() const;
  private:
  bool _internal_has_lobby() const;
  public:
  void clear_lobby();
  const ::Lobby& lobby() const;
  PROTOBUF_MUST_USE_RESULT ::Lobby* release_lobby();
  ::Lobby* mutable_lobby();
  void set_allocated_lobby(::Lobby* lobby);
  private:
  const ::Lobby& _internal_lobby() const;
  ::Lobby* _internal_mutable_lobby();
  public:
  void unsafe_arena_set_allocated_lobby(
      ::Lobby* lobby);
  ::Lobby* unsafe_arena_release_lobby();

  // .Lobby_Messages lobby_messages = 6;
  bool has_lobby_messages() const;
  private:
  bool _internal_has_lobby_messages() const;
  public:
  void clear_lobby_messages();
  const ::Lobby_Messages& lobby_messages() const;
  PROTOBUF_MUST_USE_RESULT ::Lobby_Messages* release_lobby_messages();
  ::Lobby_Messages* mutable_lobby_messages();
  void set_allocated_lobby_messages(::Lobby_Messages* lobby_messages);
  private:
  const ::Lobby_Messages& _internal_lobby_messages() const;
  ::Lobby_Messages* _internal_mutable_lobby_messages();
  public:
  void unsafe_arena_set_allocated_lobby_messages(
      ::Lobby_Messages* lobby_messages);
  ::Lobby_Messages* unsafe_arena_release_lobby_messages();

  // .Network network = 7;
  bool has_network() const;
  private:
  bool _internal_has_network() const;
  public:
  void clear_network();
  const ::Network& network() const;
  PROTOBUF_MUST_USE_RESULT ::Network* release_network();
  ::Network* mutable_network();
  void set_allocated_network(::Network* network);
  private:
  const ::Network& _internal_network() const;
  ::Network* _internal_mutable_network();
  public:
  void unsafe_arena_set_allocated_network(
      ::Network* network);
  ::Network* unsafe_arena_release_network();

  // .Gameserver gameserver = 8;
  bool has_gameserver() const;
  private:
  bool _internal_has_gameserver() const;
  public:
  void clear_gameserver();
  const ::Gameserver& gameserver() const;
  PROTOBUF_MUST_USE_RESULT ::Gameserver* release_gameserver();
  ::Gameserver* mutable_gameserver();
  void set_allocated_gameserver(::Gameserver* gameserver);
  private:
  const ::Gameserver& _internal_gameserver() const;
  ::Gameserver* _internal_mutable_gameserver();
  public:
  void unsafe_arena_set_allocated_gameserver(
      ::Gameserver* gameserver);
  ::Gameserver* unsafe_arena_release_gameserver();

  // .Friend friend = 9;
  bool has_friend_() const;
  private:
  bool _internal_has_friend_() const;
  public:
  void clear_friend_();
  const ::Friend& friend_() const;
  PROTOBUF_MUST_USE_RESULT ::Friend* release_friend_();
  ::Friend* mutable_friend_();
  void set_allocated_friend_(::Friend* friend_);
  private:
  const ::Friend& _internal_friend_() const;
  ::Friend* _internal_mutable_friend_();
  public:
  void unsafe_arena_set_allocated_friend_(
      ::Friend* friend_);
  ::Friend* unsafe_arena_release_friend_();

  // .Auth_Ticket auth_ticket = 10;
  bool has_auth_ticket() const;
  private:
  bool _internal_has_auth_ticket() const;
  public:
  void clear_auth_ticket();
  const ::Auth_Ticket& auth_ticket() const;
  PROTOBUF_MUST_USE_RESULT ::Auth_Ticket* release_auth_ticket();
  ::Auth_Ticket* mutable_auth_ticket();
  void set_allocated_auth_ticket(::Auth_Ticket* auth_ticket);
  private:
  const ::Auth_Ticket& _internal_auth_ticket() const;
  ::Auth_Ticket* _internal_mutable_auth_ticket();
  public:
  void unsafe_arena_set_allocated_auth_ticket(
      ::Auth_Ticket* auth_ticket);
  ::Auth_Ticket* unsafe_arena_release_auth_ticket();

  // .Friend_Messages friend_messages = 11;
  bool has_friend_messages() const;
  private:
  bool _internal_has_friend_messages() const;
  public:
  void clear_friend_messages();
  const ::Friend_Messages& friend_messages() const;
  PROTOBUF_MUST_USE_RESULT ::Friend_Messages* release_friend_messages();
  ::Friend_Messages* mutable_friend_messages();
  void set_allocated_friend_messages(::Friend_Messages* friend_messages);
  private:
  const ::Friend_Messages& _internal_friend_messages() const;
  ::Friend_Messages* _internal_mutable_friend_messages();
  public:
  void unsafe_arena_set_allocated_friend_messages(
      ::Friend_Messages* friend_messages);
  ::Friend_Messages* unsafe_arena_release_friend_messages();

  // .Network_Old network_old = 12;
  bool has_network_old() const;
  private:
  bool _internal_has_network_old() const;
  public:
  void clear_network_old();
  const ::Network_Old& network_old() const;
  PROTOBUF_MUST_USE_RESULT ::Network_Old* release_network_old();
  ::Network_Old* mutable_network_old();
  void set_allocated_network_old(::Network_Old* network_old);
  private:
  const ::Network_Old& _internal_network_old() const;
  ::Network_Old* _internal_mutable_network_old();
  public:
  void unsafe_arena_set_allocated_network_old(
      ::Network_Old* network_old);
  ::Network_Old* unsafe_arena_release_network_old();

  // .Networking_Sockets networking_sockets = 13;
  bool has_networking_sockets() const;
  private:
  bool _internal_has_networking_sockets() const;
  public:
  void clear_networking_sockets();
  const ::Networking_Sockets& networking_sockets() const;
  PROTOBUF_MUST_USE_RESULT ::Networking_Sockets* release_networking_sockets();
  ::Networking_Sockets* mutable_networking_sockets();
  void set_allocated_networking_sockets(::Networking_Sockets* networking_sockets);
  private:
  const ::Networking_Sockets& _internal_networking_sockets() const;
  ::Networking_Sockets* _internal_mutable_networking_sockets();
  public:
  void unsafe_arena_set_allocated_networking_sockets(
      ::Networking_Sockets* networking_sockets);
  ::Networking_Sockets* unsafe_arena_release_networking_sockets();

  void clear_messages();
  MessagesCase messages_case() const;
  // @@protoc_insertion_point(class_scope:Common_Message)
 private:
  class _Internal;
  void set_has_announce();
  void set_has_low_level();
  void set_has_lobby();
  void set_has_lobby_messages();
  void set_has_network();
  void set_has_gameserver();
  void set_has_friend_();
  void set_has_auth_ticket();
  void set_has_friend_messages();
  void set_has_network_old();
  void set_has_networking_sockets();

  inline bool has_messages() const;
  inline void clear_has_messages();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 source_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 dest_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 source_ip_;
  ::PROTOBUF_NAMESPACE_ID::uint32 source_port_;
  union MessagesUnion {
    constexpr MessagesUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::Announce* announce_;
    ::Low_Level* low_level_;
    ::Lobby* lobby_;
    ::Lobby_Messages* lobby_messages_;
    ::Network* network_;
    ::Gameserver* gameserver_;
    ::Friend* friend__;
    ::Auth_Ticket* auth_ticket_;
    ::Friend_Messages* friend_messages_;
    ::Network_Old* network_old_;
    ::Networking_Sockets* networking_sockets_;
  } messages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_net_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Announce_Other_Peers

// uint64 id = 1;
inline void Announce_Other_Peers::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Announce_Other_Peers::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Announce_Other_Peers::id() const {
  // @@protoc_insertion_point(field_get:Announce.Other_Peers.id)
  return _internal_id();
}
inline void Announce_Other_Peers::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Announce_Other_Peers::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Announce.Other_Peers.id)
}

// uint32 ip = 2;
inline void Announce_Other_Peers::clear_ip() {
  ip_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Announce_Other_Peers::_internal_ip() const {
  return ip_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Announce_Other_Peers::ip() const {
  // @@protoc_insertion_point(field_get:Announce.Other_Peers.ip)
  return _internal_ip();
}
inline void Announce_Other_Peers::_internal_set_ip(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ip_ = value;
}
inline void Announce_Other_Peers::set_ip(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:Announce.Other_Peers.ip)
}

// uint32 udp_port = 3;
inline void Announce_Other_Peers::clear_udp_port() {
  udp_port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Announce_Other_Peers::_internal_udp_port() const {
  return udp_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Announce_Other_Peers::udp_port() const {
  // @@protoc_insertion_point(field_get:Announce.Other_Peers.udp_port)
  return _internal_udp_port();
}
inline void Announce_Other_Peers::_internal_set_udp_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  udp_port_ = value;
}
inline void Announce_Other_Peers::set_udp_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_udp_port(value);
  // @@protoc_insertion_point(field_set:Announce.Other_Peers.udp_port)
}

// uint32 appid = 4;
inline void Announce_Other_Peers::clear_appid() {
  appid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Announce_Other_Peers::_internal_appid() const {
  return appid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Announce_Other_Peers::appid() const {
  // @@protoc_insertion_point(field_get:Announce.Other_Peers.appid)
  return _internal_appid();
}
inline void Announce_Other_Peers::_internal_set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  appid_ = value;
}
inline void Announce_Other_Peers::set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:Announce.Other_Peers.appid)
}

// -------------------------------------------------------------------

// Announce

// .Announce.Types type = 1;
inline void Announce::clear_type() {
  type_ = 0;
}
inline ::Announce_Types Announce::_internal_type() const {
  return static_cast< ::Announce_Types >(type_);
}
inline ::Announce_Types Announce::type() const {
  // @@protoc_insertion_point(field_get:Announce.type)
  return _internal_type();
}
inline void Announce::_internal_set_type(::Announce_Types value) {
  
  type_ = value;
}
inline void Announce::set_type(::Announce_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Announce.type)
}

// repeated uint64 ids = 2;
inline int Announce::_internal_ids_size() const {
  return ids_.size();
}
inline int Announce::ids_size() const {
  return _internal_ids_size();
}
inline void Announce::clear_ids() {
  ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Announce::_internal_ids(int index) const {
  return ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Announce::ids(int index) const {
  // @@protoc_insertion_point(field_get:Announce.ids)
  return _internal_ids(index);
}
inline void Announce::set_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Announce.ids)
}
inline void Announce::_internal_add_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  ids_.Add(value);
}
inline void Announce::add_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_ids(value);
  // @@protoc_insertion_point(field_add:Announce.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
Announce::_internal_ids() const {
  return ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
Announce::ids() const {
  // @@protoc_insertion_point(field_list:Announce.ids)
  return _internal_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
Announce::_internal_mutable_ids() {
  return &ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
Announce::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:Announce.ids)
  return _internal_mutable_ids();
}

// uint32 tcp_port = 3;
inline void Announce::clear_tcp_port() {
  tcp_port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Announce::_internal_tcp_port() const {
  return tcp_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Announce::tcp_port() const {
  // @@protoc_insertion_point(field_get:Announce.tcp_port)
  return _internal_tcp_port();
}
inline void Announce::_internal_set_tcp_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  tcp_port_ = value;
}
inline void Announce::set_tcp_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tcp_port(value);
  // @@protoc_insertion_point(field_set:Announce.tcp_port)
}

// repeated .Announce.Other_Peers peers = 4;
inline int Announce::_internal_peers_size() const {
  return peers_.size();
}
inline int Announce::peers_size() const {
  return _internal_peers_size();
}
inline void Announce::clear_peers() {
  peers_.Clear();
}
inline ::Announce_Other_Peers* Announce::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:Announce.peers)
  return peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Announce_Other_Peers >*
Announce::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:Announce.peers)
  return &peers_;
}
inline const ::Announce_Other_Peers& Announce::_internal_peers(int index) const {
  return peers_.Get(index);
}
inline const ::Announce_Other_Peers& Announce::peers(int index) const {
  // @@protoc_insertion_point(field_get:Announce.peers)
  return _internal_peers(index);
}
inline ::Announce_Other_Peers* Announce::_internal_add_peers() {
  return peers_.Add();
}
inline ::Announce_Other_Peers* Announce::add_peers() {
  ::Announce_Other_Peers* _add = _internal_add_peers();
  // @@protoc_insertion_point(field_add:Announce.peers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Announce_Other_Peers >&
Announce::peers() const {
  // @@protoc_insertion_point(field_list:Announce.peers)
  return peers_;
}

// uint32 appid = 5;
inline void Announce::clear_appid() {
  appid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Announce::_internal_appid() const {
  return appid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Announce::appid() const {
  // @@protoc_insertion_point(field_get:Announce.appid)
  return _internal_appid();
}
inline void Announce::_internal_set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  appid_ = value;
}
inline void Announce::set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:Announce.appid)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Lobby_Member

// uint64 id = 1;
inline void Lobby_Member::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby_Member::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby_Member::id() const {
  // @@protoc_insertion_point(field_get:Lobby.Member.id)
  return _internal_id();
}
inline void Lobby_Member::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Lobby_Member::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Lobby.Member.id)
}

// map<string, bytes> values = 2;
inline int Lobby_Member::_internal_values_size() const {
  return values_.size();
}
inline int Lobby_Member::values_size() const {
  return _internal_values_size();
}
inline void Lobby_Member::clear_values() {
  values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lobby_Member::_internal_values() const {
  return values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lobby_Member::values() const {
  // @@protoc_insertion_point(field_map:Lobby.Member.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lobby_Member::_internal_mutable_values() {
  return values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lobby_Member::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:Lobby.Member.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Lobby_Gameserver

// uint64 id = 1;
inline void Lobby_Gameserver::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby_Gameserver::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby_Gameserver::id() const {
  // @@protoc_insertion_point(field_get:Lobby.Gameserver.id)
  return _internal_id();
}
inline void Lobby_Gameserver::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Lobby_Gameserver::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Lobby.Gameserver.id)
}

// uint32 ip = 2;
inline void Lobby_Gameserver::clear_ip() {
  ip_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lobby_Gameserver::_internal_ip() const {
  return ip_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lobby_Gameserver::ip() const {
  // @@protoc_insertion_point(field_get:Lobby.Gameserver.ip)
  return _internal_ip();
}
inline void Lobby_Gameserver::_internal_set_ip(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ip_ = value;
}
inline void Lobby_Gameserver::set_ip(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:Lobby.Gameserver.ip)
}

// uint32 port = 3;
inline void Lobby_Gameserver::clear_port() {
  port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lobby_Gameserver::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lobby_Gameserver::port() const {
  // @@protoc_insertion_point(field_get:Lobby.Gameserver.port)
  return _internal_port();
}
inline void Lobby_Gameserver::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  port_ = value;
}
inline void Lobby_Gameserver::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Lobby.Gameserver.port)
}

// -------------------------------------------------------------------

// Lobby

// uint64 room_id = 1;
inline void Lobby::clear_room_id() {
  room_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby::_internal_room_id() const {
  return room_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby::room_id() const {
  // @@protoc_insertion_point(field_get:Lobby.room_id)
  return _internal_room_id();
}
inline void Lobby::_internal_set_room_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  room_id_ = value;
}
inline void Lobby::set_room_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:Lobby.room_id)
}

// uint64 owner = 2;
inline void Lobby::clear_owner() {
  owner_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby::_internal_owner() const {
  return owner_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby::owner() const {
  // @@protoc_insertion_point(field_get:Lobby.owner)
  return _internal_owner();
}
inline void Lobby::_internal_set_owner(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  owner_ = value;
}
inline void Lobby::set_owner(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:Lobby.owner)
}

// map<string, bytes> values = 3;
inline int Lobby::_internal_values_size() const {
  return values_.size();
}
inline int Lobby::values_size() const {
  return _internal_values_size();
}
inline void Lobby::clear_values() {
  values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lobby::_internal_values() const {
  return values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lobby::values() const {
  // @@protoc_insertion_point(field_map:Lobby.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lobby::_internal_mutable_values() {
  return values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lobby::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:Lobby.values)
  return _internal_mutable_values();
}

// repeated .Lobby.Member members = 4;
inline int Lobby::_internal_members_size() const {
  return members_.size();
}
inline int Lobby::members_size() const {
  return _internal_members_size();
}
inline void Lobby::clear_members() {
  members_.Clear();
}
inline ::Lobby_Member* Lobby::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:Lobby.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Lobby_Member >*
Lobby::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:Lobby.members)
  return &members_;
}
inline const ::Lobby_Member& Lobby::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::Lobby_Member& Lobby::members(int index) const {
  // @@protoc_insertion_point(field_get:Lobby.members)
  return _internal_members(index);
}
inline ::Lobby_Member* Lobby::_internal_add_members() {
  return members_.Add();
}
inline ::Lobby_Member* Lobby::add_members() {
  ::Lobby_Member* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:Lobby.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Lobby_Member >&
Lobby::members() const {
  // @@protoc_insertion_point(field_list:Lobby.members)
  return members_;
}

// .Lobby.Gameserver gameserver = 5;
inline bool Lobby::_internal_has_gameserver() const {
  return this != internal_default_instance() && gameserver_ != nullptr;
}
inline bool Lobby::has_gameserver() const {
  return _internal_has_gameserver();
}
inline void Lobby::clear_gameserver() {
  if (GetArenaForAllocation() == nullptr && gameserver_ != nullptr) {
    delete gameserver_;
  }
  gameserver_ = nullptr;
}
inline const ::Lobby_Gameserver& Lobby::_internal_gameserver() const {
  const ::Lobby_Gameserver* p = gameserver_;
  return p != nullptr ? *p : reinterpret_cast<const ::Lobby_Gameserver&>(
      ::_Lobby_Gameserver_default_instance_);
}
inline const ::Lobby_Gameserver& Lobby::gameserver() const {
  // @@protoc_insertion_point(field_get:Lobby.gameserver)
  return _internal_gameserver();
}
inline void Lobby::unsafe_arena_set_allocated_gameserver(
    ::Lobby_Gameserver* gameserver) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gameserver_);
  }
  gameserver_ = gameserver;
  if (gameserver) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Lobby.gameserver)
}
inline ::Lobby_Gameserver* Lobby::release_gameserver() {
  
  ::Lobby_Gameserver* temp = gameserver_;
  gameserver_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Lobby_Gameserver* Lobby::unsafe_arena_release_gameserver() {
  // @@protoc_insertion_point(field_release:Lobby.gameserver)
  
  ::Lobby_Gameserver* temp = gameserver_;
  gameserver_ = nullptr;
  return temp;
}
inline ::Lobby_Gameserver* Lobby::_internal_mutable_gameserver() {
  
  if (gameserver_ == nullptr) {
    auto* p = CreateMaybeMessage<::Lobby_Gameserver>(GetArenaForAllocation());
    gameserver_ = p;
  }
  return gameserver_;
}
inline ::Lobby_Gameserver* Lobby::mutable_gameserver() {
  ::Lobby_Gameserver* _msg = _internal_mutable_gameserver();
  // @@protoc_insertion_point(field_mutable:Lobby.gameserver)
  return _msg;
}
inline void Lobby::set_allocated_gameserver(::Lobby_Gameserver* gameserver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gameserver_;
  }
  if (gameserver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Lobby_Gameserver>::GetOwningArena(gameserver);
    if (message_arena != submessage_arena) {
      gameserver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gameserver, submessage_arena);
    }
    
  } else {
    
  }
  gameserver_ = gameserver;
  // @@protoc_insertion_point(field_set_allocated:Lobby.gameserver)
}

// uint32 member_limit = 6;
inline void Lobby::clear_member_limit() {
  member_limit_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lobby::_internal_member_limit() const {
  return member_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lobby::member_limit() const {
  // @@protoc_insertion_point(field_get:Lobby.member_limit)
  return _internal_member_limit();
}
inline void Lobby::_internal_set_member_limit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  member_limit_ = value;
}
inline void Lobby::set_member_limit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_member_limit(value);
  // @@protoc_insertion_point(field_set:Lobby.member_limit)
}

// uint32 type = 7;
inline void Lobby::clear_type() {
  type_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lobby::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lobby::type() const {
  // @@protoc_insertion_point(field_get:Lobby.type)
  return _internal_type();
}
inline void Lobby::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  type_ = value;
}
inline void Lobby::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Lobby.type)
}

// bool joinable = 8;
inline void Lobby::clear_joinable() {
  joinable_ = false;
}
inline bool Lobby::_internal_joinable() const {
  return joinable_;
}
inline bool Lobby::joinable() const {
  // @@protoc_insertion_point(field_get:Lobby.joinable)
  return _internal_joinable();
}
inline void Lobby::_internal_set_joinable(bool value) {
  
  joinable_ = value;
}
inline void Lobby::set_joinable(bool value) {
  _internal_set_joinable(value);
  // @@protoc_insertion_point(field_set:Lobby.joinable)
}

// uint32 appid = 9;
inline void Lobby::clear_appid() {
  appid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lobby::_internal_appid() const {
  return appid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lobby::appid() const {
  // @@protoc_insertion_point(field_get:Lobby.appid)
  return _internal_appid();
}
inline void Lobby::_internal_set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  appid_ = value;
}
inline void Lobby::set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:Lobby.appid)
}

// bool deleted = 32;
inline void Lobby::clear_deleted() {
  deleted_ = false;
}
inline bool Lobby::_internal_deleted() const {
  return deleted_;
}
inline bool Lobby::deleted() const {
  // @@protoc_insertion_point(field_get:Lobby.deleted)
  return _internal_deleted();
}
inline void Lobby::_internal_set_deleted(bool value) {
  
  deleted_ = value;
}
inline void Lobby::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:Lobby.deleted)
}

// uint64 time_deleted = 33;
inline void Lobby::clear_time_deleted() {
  time_deleted_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby::_internal_time_deleted() const {
  return time_deleted_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby::time_deleted() const {
  // @@protoc_insertion_point(field_get:Lobby.time_deleted)
  return _internal_time_deleted();
}
inline void Lobby::_internal_set_time_deleted(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  time_deleted_ = value;
}
inline void Lobby::set_time_deleted(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_time_deleted(value);
  // @@protoc_insertion_point(field_set:Lobby.time_deleted)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Lobby_Messages

// uint64 id = 1;
inline void Lobby_Messages::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby_Messages::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby_Messages::id() const {
  // @@protoc_insertion_point(field_get:Lobby_Messages.id)
  return _internal_id();
}
inline void Lobby_Messages::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Lobby_Messages::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Lobby_Messages.id)
}

// .Lobby_Messages.Types type = 2;
inline void Lobby_Messages::clear_type() {
  type_ = 0;
}
inline ::Lobby_Messages_Types Lobby_Messages::_internal_type() const {
  return static_cast< ::Lobby_Messages_Types >(type_);
}
inline ::Lobby_Messages_Types Lobby_Messages::type() const {
  // @@protoc_insertion_point(field_get:Lobby_Messages.type)
  return _internal_type();
}
inline void Lobby_Messages::_internal_set_type(::Lobby_Messages_Types value) {
  
  type_ = value;
}
inline void Lobby_Messages::set_type(::Lobby_Messages_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Lobby_Messages.type)
}

// uint64 idata = 3;
inline void Lobby_Messages::clear_idata() {
  idata_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby_Messages::_internal_idata() const {
  return idata_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lobby_Messages::idata() const {
  // @@protoc_insertion_point(field_get:Lobby_Messages.idata)
  return _internal_idata();
}
inline void Lobby_Messages::_internal_set_idata(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  idata_ = value;
}
inline void Lobby_Messages::set_idata(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_idata(value);
  // @@protoc_insertion_point(field_set:Lobby_Messages.idata)
}

// bytes bdata = 4;
inline void Lobby_Messages::clear_bdata() {
  bdata_.ClearToEmpty();
}
inline const std::string& Lobby_Messages::bdata() const {
  // @@protoc_insertion_point(field_get:Lobby_Messages.bdata)
  return _internal_bdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Lobby_Messages::set_bdata(ArgT0&& arg0, ArgT... args) {
 
 bdata_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Lobby_Messages.bdata)
}
inline std::string* Lobby_Messages::mutable_bdata() {
  std::string* _s = _internal_mutable_bdata();
  // @@protoc_insertion_point(field_mutable:Lobby_Messages.bdata)
  return _s;
}
inline const std::string& Lobby_Messages::_internal_bdata() const {
  return bdata_.Get();
}
inline void Lobby_Messages::_internal_set_bdata(const std::string& value) {
  
  bdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Lobby_Messages::_internal_mutable_bdata() {
  
  return bdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Lobby_Messages::release_bdata() {
  // @@protoc_insertion_point(field_release:Lobby_Messages.bdata)
  return bdata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Lobby_Messages::set_allocated_bdata(std::string* bdata) {
  if (bdata != nullptr) {
    
  } else {
    
  }
  bdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bdata,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Lobby_Messages.bdata)
}

// map<string, bytes> map = 5;
inline int Lobby_Messages::_internal_map_size() const {
  return map_.size();
}
inline int Lobby_Messages::map_size() const {
  return _internal_map_size();
}
inline void Lobby_Messages::clear_map() {
  map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lobby_Messages::_internal_map() const {
  return map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lobby_Messages::map() const {
  // @@protoc_insertion_point(field_map:Lobby_Messages.map)
  return _internal_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lobby_Messages::_internal_mutable_map() {
  return map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lobby_Messages::mutable_map() {
  // @@protoc_insertion_point(field_mutable_map:Lobby_Messages.map)
  return _internal_mutable_map();
}

// -------------------------------------------------------------------

// Low_Level

// .Low_Level.Types type = 1;
inline void Low_Level::clear_type() {
  type_ = 0;
}
inline ::Low_Level_Types Low_Level::_internal_type() const {
  return static_cast< ::Low_Level_Types >(type_);
}
inline ::Low_Level_Types Low_Level::type() const {
  // @@protoc_insertion_point(field_get:Low_Level.type)
  return _internal_type();
}
inline void Low_Level::_internal_set_type(::Low_Level_Types value) {
  
  type_ = value;
}
inline void Low_Level::set_type(::Low_Level_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Low_Level.type)
}

// -------------------------------------------------------------------

// Network

// uint32 channel = 1;
inline void Network::clear_channel() {
  channel_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Network::_internal_channel() const {
  return channel_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Network::channel() const {
  // @@protoc_insertion_point(field_get:Network.channel)
  return _internal_channel();
}
inline void Network::_internal_set_channel(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  channel_ = value;
}
inline void Network::set_channel(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:Network.channel)
}

// bytes data = 2;
inline void Network::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Network::data() const {
  // @@protoc_insertion_point(field_get:Network.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Network::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Network.data)
}
inline std::string* Network::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Network.data)
  return _s;
}
inline const std::string& Network::_internal_data() const {
  return data_.Get();
}
inline void Network::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Network::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Network::release_data() {
  // @@protoc_insertion_point(field_release:Network.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Network::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Network.data)
}

// .Network.Types type = 3;
inline void Network::clear_type() {
  type_ = 0;
}
inline ::Network_Types Network::_internal_type() const {
  return static_cast< ::Network_Types >(type_);
}
inline ::Network_Types Network::type() const {
  // @@protoc_insertion_point(field_get:Network.type)
  return _internal_type();
}
inline void Network::_internal_set_type(::Network_Types value) {
  
  type_ = value;
}
inline void Network::set_type(::Network_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Network.type)
}

// bool processed = 128;
inline void Network::clear_processed() {
  processed_ = false;
}
inline bool Network::_internal_processed() const {
  return processed_;
}
inline bool Network::processed() const {
  // @@protoc_insertion_point(field_get:Network.processed)
  return _internal_processed();
}
inline void Network::_internal_set_processed(bool value) {
  
  processed_ = value;
}
inline void Network::set_processed(bool value) {
  _internal_set_processed(value);
  // @@protoc_insertion_point(field_set:Network.processed)
}

// uint64 time_processed = 129;
inline void Network::clear_time_processed() {
  time_processed_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Network::_internal_time_processed() const {
  return time_processed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Network::time_processed() const {
  // @@protoc_insertion_point(field_get:Network.time_processed)
  return _internal_time_processed();
}
inline void Network::_internal_set_time_processed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  time_processed_ = value;
}
inline void Network::set_time_processed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_time_processed(value);
  // @@protoc_insertion_point(field_set:Network.time_processed)
}

// -------------------------------------------------------------------

// Network_Old

// .Network_Old.Types type = 1;
inline void Network_Old::clear_type() {
  type_ = 0;
}
inline ::Network_Old_Types Network_Old::_internal_type() const {
  return static_cast< ::Network_Old_Types >(type_);
}
inline ::Network_Old_Types Network_Old::type() const {
  // @@protoc_insertion_point(field_get:Network_Old.type)
  return _internal_type();
}
inline void Network_Old::_internal_set_type(::Network_Old_Types value) {
  
  type_ = value;
}
inline void Network_Old::set_type(::Network_Old_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Network_Old.type)
}

// uint64 connection_id = 2;
inline void Network_Old::clear_connection_id() {
  connection_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Network_Old::_internal_connection_id() const {
  return connection_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Network_Old::connection_id() const {
  // @@protoc_insertion_point(field_get:Network_Old.connection_id)
  return _internal_connection_id();
}
inline void Network_Old::_internal_set_connection_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  connection_id_ = value;
}
inline void Network_Old::set_connection_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_connection_id(value);
  // @@protoc_insertion_point(field_set:Network_Old.connection_id)
}

// uint64 connection_id_from = 3;
inline void Network_Old::clear_connection_id_from() {
  connection_id_from_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Network_Old::_internal_connection_id_from() const {
  return connection_id_from_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Network_Old::connection_id_from() const {
  // @@protoc_insertion_point(field_get:Network_Old.connection_id_from)
  return _internal_connection_id_from();
}
inline void Network_Old::_internal_set_connection_id_from(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  connection_id_from_ = value;
}
inline void Network_Old::set_connection_id_from(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_connection_id_from(value);
  // @@protoc_insertion_point(field_set:Network_Old.connection_id_from)
}

// uint32 port = 4;
inline void Network_Old::clear_port() {
  port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Network_Old::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Network_Old::port() const {
  // @@protoc_insertion_point(field_get:Network_Old.port)
  return _internal_port();
}
inline void Network_Old::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  port_ = value;
}
inline void Network_Old::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Network_Old.port)
}

// bytes data = 5;
inline void Network_Old::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Network_Old::data() const {
  // @@protoc_insertion_point(field_get:Network_Old.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Network_Old::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Network_Old.data)
}
inline std::string* Network_Old::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Network_Old.data)
  return _s;
}
inline const std::string& Network_Old::_internal_data() const {
  return data_.Get();
}
inline void Network_Old::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Network_Old::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Network_Old::release_data() {
  // @@protoc_insertion_point(field_release:Network_Old.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Network_Old::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Network_Old.data)
}

// -------------------------------------------------------------------

// Networking_Sockets

// .Networking_Sockets.Types type = 1;
inline void Networking_Sockets::clear_type() {
  type_ = 0;
}
inline ::Networking_Sockets_Types Networking_Sockets::_internal_type() const {
  return static_cast< ::Networking_Sockets_Types >(type_);
}
inline ::Networking_Sockets_Types Networking_Sockets::type() const {
  // @@protoc_insertion_point(field_get:Networking_Sockets.type)
  return _internal_type();
}
inline void Networking_Sockets::_internal_set_type(::Networking_Sockets_Types value) {
  
  type_ = value;
}
inline void Networking_Sockets::set_type(::Networking_Sockets_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Networking_Sockets.type)
}

// uint32 port = 2;
inline void Networking_Sockets::clear_port() {
  port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Networking_Sockets::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Networking_Sockets::port() const {
  // @@protoc_insertion_point(field_get:Networking_Sockets.port)
  return _internal_port();
}
inline void Networking_Sockets::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  port_ = value;
}
inline void Networking_Sockets::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Networking_Sockets.port)
}

// uint64 connection_id = 3;
inline void Networking_Sockets::clear_connection_id() {
  connection_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Networking_Sockets::_internal_connection_id() const {
  return connection_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Networking_Sockets::connection_id() const {
  // @@protoc_insertion_point(field_get:Networking_Sockets.connection_id)
  return _internal_connection_id();
}
inline void Networking_Sockets::_internal_set_connection_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  connection_id_ = value;
}
inline void Networking_Sockets::set_connection_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_connection_id(value);
  // @@protoc_insertion_point(field_set:Networking_Sockets.connection_id)
}

// uint64 connection_id_from = 4;
inline void Networking_Sockets::clear_connection_id_from() {
  connection_id_from_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Networking_Sockets::_internal_connection_id_from() const {
  return connection_id_from_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Networking_Sockets::connection_id_from() const {
  // @@protoc_insertion_point(field_get:Networking_Sockets.connection_id_from)
  return _internal_connection_id_from();
}
inline void Networking_Sockets::_internal_set_connection_id_from(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  connection_id_from_ = value;
}
inline void Networking_Sockets::set_connection_id_from(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_connection_id_from(value);
  // @@protoc_insertion_point(field_set:Networking_Sockets.connection_id_from)
}

// bytes data = 5;
inline void Networking_Sockets::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Networking_Sockets::data() const {
  // @@protoc_insertion_point(field_get:Networking_Sockets.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Networking_Sockets::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Networking_Sockets.data)
}
inline std::string* Networking_Sockets::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Networking_Sockets.data)
  return _s;
}
inline const std::string& Networking_Sockets::_internal_data() const {
  return data_.Get();
}
inline void Networking_Sockets::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Networking_Sockets::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Networking_Sockets::release_data() {
  // @@protoc_insertion_point(field_release:Networking_Sockets.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Networking_Sockets::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Networking_Sockets.data)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Gameserver

// uint64 id = 1;
inline void Gameserver::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Gameserver::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Gameserver::id() const {
  // @@protoc_insertion_point(field_get:Gameserver.id)
  return _internal_id();
}
inline void Gameserver::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Gameserver::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Gameserver.id)
}

// bytes game_description = 2;
inline void Gameserver::clear_game_description() {
  game_description_.ClearToEmpty();
}
inline const std::string& Gameserver::game_description() const {
  // @@protoc_insertion_point(field_get:Gameserver.game_description)
  return _internal_game_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_game_description(ArgT0&& arg0, ArgT... args) {
 
 game_description_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.game_description)
}
inline std::string* Gameserver::mutable_game_description() {
  std::string* _s = _internal_mutable_game_description();
  // @@protoc_insertion_point(field_mutable:Gameserver.game_description)
  return _s;
}
inline const std::string& Gameserver::_internal_game_description() const {
  return game_description_.Get();
}
inline void Gameserver::_internal_set_game_description(const std::string& value) {
  
  game_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_game_description() {
  
  return game_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Gameserver::release_game_description() {
  // @@protoc_insertion_point(field_release:Gameserver.game_description)
  return game_description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Gameserver::set_allocated_game_description(std::string* game_description) {
  if (game_description != nullptr) {
    
  } else {
    
  }
  game_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Gameserver.game_description)
}

// bytes mod_dir = 3;
inline void Gameserver::clear_mod_dir() {
  mod_dir_.ClearToEmpty();
}
inline const std::string& Gameserver::mod_dir() const {
  // @@protoc_insertion_point(field_get:Gameserver.mod_dir)
  return _internal_mod_dir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_mod_dir(ArgT0&& arg0, ArgT... args) {
 
 mod_dir_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.mod_dir)
}
inline std::string* Gameserver::mutable_mod_dir() {
  std::string* _s = _internal_mutable_mod_dir();
  // @@protoc_insertion_point(field_mutable:Gameserver.mod_dir)
  return _s;
}
inline const std::string& Gameserver::_internal_mod_dir() const {
  return mod_dir_.Get();
}
inline void Gameserver::_internal_set_mod_dir(const std::string& value) {
  
  mod_dir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_mod_dir() {
  
  return mod_dir_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Gameserver::release_mod_dir() {
  // @@protoc_insertion_point(field_release:Gameserver.mod_dir)
  return mod_dir_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Gameserver::set_allocated_mod_dir(std::string* mod_dir) {
  if (mod_dir != nullptr) {
    
  } else {
    
  }
  mod_dir_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mod_dir,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Gameserver.mod_dir)
}

// bool dedicated_server = 4;
inline void Gameserver::clear_dedicated_server() {
  dedicated_server_ = false;
}
inline bool Gameserver::_internal_dedicated_server() const {
  return dedicated_server_;
}
inline bool Gameserver::dedicated_server() const {
  // @@protoc_insertion_point(field_get:Gameserver.dedicated_server)
  return _internal_dedicated_server();
}
inline void Gameserver::_internal_set_dedicated_server(bool value) {
  
  dedicated_server_ = value;
}
inline void Gameserver::set_dedicated_server(bool value) {
  _internal_set_dedicated_server(value);
  // @@protoc_insertion_point(field_set:Gameserver.dedicated_server)
}

// uint32 max_player_count = 5;
inline void Gameserver::clear_max_player_count() {
  max_player_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::_internal_max_player_count() const {
  return max_player_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::max_player_count() const {
  // @@protoc_insertion_point(field_get:Gameserver.max_player_count)
  return _internal_max_player_count();
}
inline void Gameserver::_internal_set_max_player_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  max_player_count_ = value;
}
inline void Gameserver::set_max_player_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_player_count(value);
  // @@protoc_insertion_point(field_set:Gameserver.max_player_count)
}

// uint32 bot_player_count = 6;
inline void Gameserver::clear_bot_player_count() {
  bot_player_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::_internal_bot_player_count() const {
  return bot_player_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::bot_player_count() const {
  // @@protoc_insertion_point(field_get:Gameserver.bot_player_count)
  return _internal_bot_player_count();
}
inline void Gameserver::_internal_set_bot_player_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  bot_player_count_ = value;
}
inline void Gameserver::set_bot_player_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_bot_player_count(value);
  // @@protoc_insertion_point(field_set:Gameserver.bot_player_count)
}

// bytes server_name = 7;
inline void Gameserver::clear_server_name() {
  server_name_.ClearToEmpty();
}
inline const std::string& Gameserver::server_name() const {
  // @@protoc_insertion_point(field_get:Gameserver.server_name)
  return _internal_server_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_server_name(ArgT0&& arg0, ArgT... args) {
 
 server_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.server_name)
}
inline std::string* Gameserver::mutable_server_name() {
  std::string* _s = _internal_mutable_server_name();
  // @@protoc_insertion_point(field_mutable:Gameserver.server_name)
  return _s;
}
inline const std::string& Gameserver::_internal_server_name() const {
  return server_name_.Get();
}
inline void Gameserver::_internal_set_server_name(const std::string& value) {
  
  server_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_server_name() {
  
  return server_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Gameserver::release_server_name() {
  // @@protoc_insertion_point(field_release:Gameserver.server_name)
  return server_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Gameserver::set_allocated_server_name(std::string* server_name) {
  if (server_name != nullptr) {
    
  } else {
    
  }
  server_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Gameserver.server_name)
}

// bytes map_name = 8;
inline void Gameserver::clear_map_name() {
  map_name_.ClearToEmpty();
}
inline const std::string& Gameserver::map_name() const {
  // @@protoc_insertion_point(field_get:Gameserver.map_name)
  return _internal_map_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_map_name(ArgT0&& arg0, ArgT... args) {
 
 map_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.map_name)
}
inline std::string* Gameserver::mutable_map_name() {
  std::string* _s = _internal_mutable_map_name();
  // @@protoc_insertion_point(field_mutable:Gameserver.map_name)
  return _s;
}
inline const std::string& Gameserver::_internal_map_name() const {
  return map_name_.Get();
}
inline void Gameserver::_internal_set_map_name(const std::string& value) {
  
  map_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_map_name() {
  
  return map_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Gameserver::release_map_name() {
  // @@protoc_insertion_point(field_release:Gameserver.map_name)
  return map_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Gameserver::set_allocated_map_name(std::string* map_name) {
  if (map_name != nullptr) {
    
  } else {
    
  }
  map_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Gameserver.map_name)
}

// bool password_protected = 9;
inline void Gameserver::clear_password_protected() {
  password_protected_ = false;
}
inline bool Gameserver::_internal_password_protected() const {
  return password_protected_;
}
inline bool Gameserver::password_protected() const {
  // @@protoc_insertion_point(field_get:Gameserver.password_protected)
  return _internal_password_protected();
}
inline void Gameserver::_internal_set_password_protected(bool value) {
  
  password_protected_ = value;
}
inline void Gameserver::set_password_protected(bool value) {
  _internal_set_password_protected(value);
  // @@protoc_insertion_point(field_set:Gameserver.password_protected)
}

// uint32 spectator_port = 10;
inline void Gameserver::clear_spectator_port() {
  spectator_port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::_internal_spectator_port() const {
  return spectator_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::spectator_port() const {
  // @@protoc_insertion_point(field_get:Gameserver.spectator_port)
  return _internal_spectator_port();
}
inline void Gameserver::_internal_set_spectator_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  spectator_port_ = value;
}
inline void Gameserver::set_spectator_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_spectator_port(value);
  // @@protoc_insertion_point(field_set:Gameserver.spectator_port)
}

// bytes spectator_server_name = 11;
inline void Gameserver::clear_spectator_server_name() {
  spectator_server_name_.ClearToEmpty();
}
inline const std::string& Gameserver::spectator_server_name() const {
  // @@protoc_insertion_point(field_get:Gameserver.spectator_server_name)
  return _internal_spectator_server_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_spectator_server_name(ArgT0&& arg0, ArgT... args) {
 
 spectator_server_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.spectator_server_name)
}
inline std::string* Gameserver::mutable_spectator_server_name() {
  std::string* _s = _internal_mutable_spectator_server_name();
  // @@protoc_insertion_point(field_mutable:Gameserver.spectator_server_name)
  return _s;
}
inline const std::string& Gameserver::_internal_spectator_server_name() const {
  return spectator_server_name_.Get();
}
inline void Gameserver::_internal_set_spectator_server_name(const std::string& value) {
  
  spectator_server_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_spectator_server_name() {
  
  return spectator_server_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Gameserver::release_spectator_server_name() {
  // @@protoc_insertion_point(field_release:Gameserver.spectator_server_name)
  return spectator_server_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Gameserver::set_allocated_spectator_server_name(std::string* spectator_server_name) {
  if (spectator_server_name != nullptr) {
    
  } else {
    
  }
  spectator_server_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), spectator_server_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Gameserver.spectator_server_name)
}

// map<string, bytes> values = 12;
inline int Gameserver::_internal_values_size() const {
  return values_.size();
}
inline int Gameserver::values_size() const {
  return _internal_values_size();
}
inline void Gameserver::clear_values() {
  values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Gameserver::_internal_values() const {
  return values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Gameserver::values() const {
  // @@protoc_insertion_point(field_map:Gameserver.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Gameserver::_internal_mutable_values() {
  return values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Gameserver::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:Gameserver.values)
  return _internal_mutable_values();
}

// bytes tags = 13;
inline void Gameserver::clear_tags() {
  tags_.ClearToEmpty();
}
inline const std::string& Gameserver::tags() const {
  // @@protoc_insertion_point(field_get:Gameserver.tags)
  return _internal_tags();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_tags(ArgT0&& arg0, ArgT... args) {
 
 tags_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.tags)
}
inline std::string* Gameserver::mutable_tags() {
  std::string* _s = _internal_mutable_tags();
  // @@protoc_insertion_point(field_mutable:Gameserver.tags)
  return _s;
}
inline const std::string& Gameserver::_internal_tags() const {
  return tags_.Get();
}
inline void Gameserver::_internal_set_tags(const std::string& value) {
  
  tags_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_tags() {
  
  return tags_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Gameserver::release_tags() {
  // @@protoc_insertion_point(field_release:Gameserver.tags)
  return tags_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Gameserver::set_allocated_tags(std::string* tags) {
  if (tags != nullptr) {
    
  } else {
    
  }
  tags_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tags,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Gameserver.tags)
}

// bytes gamedata = 14;
inline void Gameserver::clear_gamedata() {
  gamedata_.ClearToEmpty();
}
inline const std::string& Gameserver::gamedata() const {
  // @@protoc_insertion_point(field_get:Gameserver.gamedata)
  return _internal_gamedata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_gamedata(ArgT0&& arg0, ArgT... args) {
 
 gamedata_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.gamedata)
}
inline std::string* Gameserver::mutable_gamedata() {
  std::string* _s = _internal_mutable_gamedata();
  // @@protoc_insertion_point(field_mutable:Gameserver.gamedata)
  return _s;
}
inline const std::string& Gameserver::_internal_gamedata() const {
  return gamedata_.Get();
}
inline void Gameserver::_internal_set_gamedata(const std::string& value) {
  
  gamedata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_gamedata() {
  
  return gamedata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Gameserver::release_gamedata() {
  // @@protoc_insertion_point(field_release:Gameserver.gamedata)
  return gamedata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Gameserver::set_allocated_gamedata(std::string* gamedata) {
  if (gamedata != nullptr) {
    
  } else {
    
  }
  gamedata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamedata,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Gameserver.gamedata)
}

// bytes region = 15;
inline void Gameserver::clear_region() {
  region_.ClearToEmpty();
}
inline const std::string& Gameserver::region() const {
  // @@protoc_insertion_point(field_get:Gameserver.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_region(ArgT0&& arg0, ArgT... args) {
 
 region_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.region)
}
inline std::string* Gameserver::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:Gameserver.region)
  return _s;
}
inline const std::string& Gameserver::_internal_region() const {
  return region_.Get();
}
inline void Gameserver::_internal_set_region(const std::string& value) {
  
  region_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_region() {
  
  return region_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Gameserver::release_region() {
  // @@protoc_insertion_point(field_release:Gameserver.region)
  return region_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Gameserver::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Gameserver.region)
}

// bytes product = 16;
inline void Gameserver::clear_product() {
  product_.ClearToEmpty();
}
inline const std::string& Gameserver::product() const {
  // @@protoc_insertion_point(field_get:Gameserver.product)
  return _internal_product();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_product(ArgT0&& arg0, ArgT... args) {
 
 product_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.product)
}
inline std::string* Gameserver::mutable_product() {
  std::string* _s = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:Gameserver.product)
  return _s;
}
inline const std::string& Gameserver::_internal_product() const {
  return product_.Get();
}
inline void Gameserver::_internal_set_product(const std::string& value) {
  
  product_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_product() {
  
  return product_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Gameserver::release_product() {
  // @@protoc_insertion_point(field_release:Gameserver.product)
  return product_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Gameserver::set_allocated_product(std::string* product) {
  if (product != nullptr) {
    
  } else {
    
  }
  product_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Gameserver.product)
}

// bool secure = 17;
inline void Gameserver::clear_secure() {
  secure_ = false;
}
inline bool Gameserver::_internal_secure() const {
  return secure_;
}
inline bool Gameserver::secure() const {
  // @@protoc_insertion_point(field_get:Gameserver.secure)
  return _internal_secure();
}
inline void Gameserver::_internal_set_secure(bool value) {
  
  secure_ = value;
}
inline void Gameserver::set_secure(bool value) {
  _internal_set_secure(value);
  // @@protoc_insertion_point(field_set:Gameserver.secure)
}

// uint32 num_players = 18;
inline void Gameserver::clear_num_players() {
  num_players_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::_internal_num_players() const {
  return num_players_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::num_players() const {
  // @@protoc_insertion_point(field_get:Gameserver.num_players)
  return _internal_num_players();
}
inline void Gameserver::_internal_set_num_players(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  num_players_ = value;
}
inline void Gameserver::set_num_players(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_players(value);
  // @@protoc_insertion_point(field_set:Gameserver.num_players)
}

// uint32 version = 19;
inline void Gameserver::clear_version() {
  version_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::version() const {
  // @@protoc_insertion_point(field_get:Gameserver.version)
  return _internal_version();
}
inline void Gameserver::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  version_ = value;
}
inline void Gameserver::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:Gameserver.version)
}

// uint32 ip = 32;
inline void Gameserver::clear_ip() {
  ip_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::_internal_ip() const {
  return ip_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::ip() const {
  // @@protoc_insertion_point(field_get:Gameserver.ip)
  return _internal_ip();
}
inline void Gameserver::_internal_set_ip(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ip_ = value;
}
inline void Gameserver::set_ip(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:Gameserver.ip)
}

// uint32 port = 33;
inline void Gameserver::clear_port() {
  port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::port() const {
  // @@protoc_insertion_point(field_get:Gameserver.port)
  return _internal_port();
}
inline void Gameserver::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  port_ = value;
}
inline void Gameserver::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Gameserver.port)
}

// uint32 query_port = 34;
inline void Gameserver::clear_query_port() {
  query_port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::_internal_query_port() const {
  return query_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::query_port() const {
  // @@protoc_insertion_point(field_get:Gameserver.query_port)
  return _internal_query_port();
}
inline void Gameserver::_internal_set_query_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  query_port_ = value;
}
inline void Gameserver::set_query_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_query_port(value);
  // @@protoc_insertion_point(field_set:Gameserver.query_port)
}

// uint32 appid = 35;
inline void Gameserver::clear_appid() {
  appid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::_internal_appid() const {
  return appid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Gameserver::appid() const {
  // @@protoc_insertion_point(field_get:Gameserver.appid)
  return _internal_appid();
}
inline void Gameserver::_internal_set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  appid_ = value;
}
inline void Gameserver::set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:Gameserver.appid)
}

// bool offline = 48;
inline void Gameserver::clear_offline() {
  offline_ = false;
}
inline bool Gameserver::_internal_offline() const {
  return offline_;
}
inline bool Gameserver::offline() const {
  // @@protoc_insertion_point(field_get:Gameserver.offline)
  return _internal_offline();
}
inline void Gameserver::_internal_set_offline(bool value) {
  
  offline_ = value;
}
inline void Gameserver::set_offline(bool value) {
  _internal_set_offline(value);
  // @@protoc_insertion_point(field_set:Gameserver.offline)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Friend

// uint64 id = 1;
inline void Friend::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Friend::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Friend::id() const {
  // @@protoc_insertion_point(field_get:Friend.id)
  return _internal_id();
}
inline void Friend::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Friend::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Friend.id)
}

// bytes name = 2;
inline void Friend::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Friend::name() const {
  // @@protoc_insertion_point(field_get:Friend.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Friend::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Friend.name)
}
inline std::string* Friend::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Friend.name)
  return _s;
}
inline const std::string& Friend::_internal_name() const {
  return name_.Get();
}
inline void Friend::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Friend::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Friend::release_name() {
  // @@protoc_insertion_point(field_release:Friend.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Friend::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Friend.name)
}

// map<string, bytes> rich_presence = 3;
inline int Friend::_internal_rich_presence_size() const {
  return rich_presence_.size();
}
inline int Friend::rich_presence_size() const {
  return _internal_rich_presence_size();
}
inline void Friend::clear_rich_presence() {
  rich_presence_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Friend::_internal_rich_presence() const {
  return rich_presence_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Friend::rich_presence() const {
  // @@protoc_insertion_point(field_map:Friend.rich_presence)
  return _internal_rich_presence();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Friend::_internal_mutable_rich_presence() {
  return rich_presence_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Friend::mutable_rich_presence() {
  // @@protoc_insertion_point(field_mutable_map:Friend.rich_presence)
  return _internal_mutable_rich_presence();
}

// uint32 appid = 4;
inline void Friend::clear_appid() {
  appid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Friend::_internal_appid() const {
  return appid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Friend::appid() const {
  // @@protoc_insertion_point(field_get:Friend.appid)
  return _internal_appid();
}
inline void Friend::_internal_set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  appid_ = value;
}
inline void Friend::set_appid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:Friend.appid)
}

// uint64 lobby_id = 5;
inline void Friend::clear_lobby_id() {
  lobby_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Friend::_internal_lobby_id() const {
  return lobby_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Friend::lobby_id() const {
  // @@protoc_insertion_point(field_get:Friend.lobby_id)
  return _internal_lobby_id();
}
inline void Friend::_internal_set_lobby_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  lobby_id_ = value;
}
inline void Friend::set_lobby_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_lobby_id(value);
  // @@protoc_insertion_point(field_set:Friend.lobby_id)
}

// -------------------------------------------------------------------

// Auth_Ticket

// uint32 number = 1;
inline void Auth_Ticket::clear_number() {
  number_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Auth_Ticket::_internal_number() const {
  return number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Auth_Ticket::number() const {
  // @@protoc_insertion_point(field_get:Auth_Ticket.number)
  return _internal_number();
}
inline void Auth_Ticket::_internal_set_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  number_ = value;
}
inline void Auth_Ticket::set_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:Auth_Ticket.number)
}

// .Auth_Ticket.Types type = 2;
inline void Auth_Ticket::clear_type() {
  type_ = 0;
}
inline ::Auth_Ticket_Types Auth_Ticket::_internal_type() const {
  return static_cast< ::Auth_Ticket_Types >(type_);
}
inline ::Auth_Ticket_Types Auth_Ticket::type() const {
  // @@protoc_insertion_point(field_get:Auth_Ticket.type)
  return _internal_type();
}
inline void Auth_Ticket::_internal_set_type(::Auth_Ticket_Types value) {
  
  type_ = value;
}
inline void Auth_Ticket::set_type(::Auth_Ticket_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Auth_Ticket.type)
}

// -------------------------------------------------------------------

// Friend_Messages

// .Friend_Messages.Types type = 1;
inline void Friend_Messages::clear_type() {
  type_ = 0;
}
inline ::Friend_Messages_Types Friend_Messages::_internal_type() const {
  return static_cast< ::Friend_Messages_Types >(type_);
}
inline ::Friend_Messages_Types Friend_Messages::type() const {
  // @@protoc_insertion_point(field_get:Friend_Messages.type)
  return _internal_type();
}
inline void Friend_Messages::_internal_set_type(::Friend_Messages_Types value) {
  
  type_ = value;
}
inline void Friend_Messages::set_type(::Friend_Messages_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Friend_Messages.type)
}

// uint64 lobby_id = 2;
inline bool Friend_Messages::_internal_has_lobby_id() const {
  return invite_data_case() == kLobbyId;
}
inline bool Friend_Messages::has_lobby_id() const {
  return _internal_has_lobby_id();
}
inline void Friend_Messages::set_has_lobby_id() {
  _oneof_case_[0] = kLobbyId;
}
inline void Friend_Messages::clear_lobby_id() {
  if (_internal_has_lobby_id()) {
    invite_data_.lobby_id_ = uint64_t{0u};
    clear_has_invite_data();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Friend_Messages::_internal_lobby_id() const {
  if (_internal_has_lobby_id()) {
    return invite_data_.lobby_id_;
  }
  return uint64_t{0u};
}
inline void Friend_Messages::_internal_set_lobby_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_lobby_id()) {
    clear_invite_data();
    set_has_lobby_id();
  }
  invite_data_.lobby_id_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Friend_Messages::lobby_id() const {
  // @@protoc_insertion_point(field_get:Friend_Messages.lobby_id)
  return _internal_lobby_id();
}
inline void Friend_Messages::set_lobby_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_lobby_id(value);
  // @@protoc_insertion_point(field_set:Friend_Messages.lobby_id)
}

// bytes connect_str = 3;
inline bool Friend_Messages::_internal_has_connect_str() const {
  return invite_data_case() == kConnectStr;
}
inline bool Friend_Messages::has_connect_str() const {
  return _internal_has_connect_str();
}
inline void Friend_Messages::set_has_connect_str() {
  _oneof_case_[0] = kConnectStr;
}
inline void Friend_Messages::clear_connect_str() {
  if (_internal_has_connect_str()) {
    invite_data_.connect_str_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_invite_data();
  }
}
inline const std::string& Friend_Messages::connect_str() const {
  // @@protoc_insertion_point(field_get:Friend_Messages.connect_str)
  return _internal_connect_str();
}
template <typename ArgT0, typename... ArgT>
inline void Friend_Messages::set_connect_str(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_connect_str()) {
    clear_invite_data();
    set_has_connect_str();
    invite_data_.connect_str_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  invite_data_.connect_str_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Friend_Messages.connect_str)
}
inline std::string* Friend_Messages::mutable_connect_str() {
  std::string* _s = _internal_mutable_connect_str();
  // @@protoc_insertion_point(field_mutable:Friend_Messages.connect_str)
  return _s;
}
inline const std::string& Friend_Messages::_internal_connect_str() const {
  if (_internal_has_connect_str()) {
    return invite_data_.connect_str_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Friend_Messages::_internal_set_connect_str(const std::string& value) {
  if (!_internal_has_connect_str()) {
    clear_invite_data();
    set_has_connect_str();
    invite_data_.connect_str_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  invite_data_.connect_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Friend_Messages::_internal_mutable_connect_str() {
  if (!_internal_has_connect_str()) {
    clear_invite_data();
    set_has_connect_str();
    invite_data_.connect_str_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return invite_data_.connect_str_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Friend_Messages::release_connect_str() {
  // @@protoc_insertion_point(field_release:Friend_Messages.connect_str)
  if (_internal_has_connect_str()) {
    clear_has_invite_data();
    return invite_data_.connect_str_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Friend_Messages::set_allocated_connect_str(std::string* connect_str) {
  if (has_invite_data()) {
    clear_invite_data();
  }
  if (connect_str != nullptr) {
    set_has_connect_str();
    invite_data_.connect_str_.UnsafeSetDefault(connect_str);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(connect_str);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:Friend_Messages.connect_str)
}

inline bool Friend_Messages::has_invite_data() const {
  return invite_data_case() != INVITE_DATA_NOT_SET;
}
inline void Friend_Messages::clear_has_invite_data() {
  _oneof_case_[0] = INVITE_DATA_NOT_SET;
}
inline Friend_Messages::InviteDataCase Friend_Messages::invite_data_case() const {
  return Friend_Messages::InviteDataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Common_Message

// uint64 source_id = 1;
inline void Common_Message::clear_source_id() {
  source_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Common_Message::_internal_source_id() const {
  return source_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Common_Message::source_id() const {
  // @@protoc_insertion_point(field_get:Common_Message.source_id)
  return _internal_source_id();
}
inline void Common_Message::_internal_set_source_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  source_id_ = value;
}
inline void Common_Message::set_source_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_source_id(value);
  // @@protoc_insertion_point(field_set:Common_Message.source_id)
}

// uint64 dest_id = 2;
inline void Common_Message::clear_dest_id() {
  dest_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Common_Message::_internal_dest_id() const {
  return dest_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Common_Message::dest_id() const {
  // @@protoc_insertion_point(field_get:Common_Message.dest_id)
  return _internal_dest_id();
}
inline void Common_Message::_internal_set_dest_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  dest_id_ = value;
}
inline void Common_Message::set_dest_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_dest_id(value);
  // @@protoc_insertion_point(field_set:Common_Message.dest_id)
}

// .Announce announce = 3;
inline bool Common_Message::_internal_has_announce() const {
  return messages_case() == kAnnounce;
}
inline bool Common_Message::has_announce() const {
  return _internal_has_announce();
}
inline void Common_Message::set_has_announce() {
  _oneof_case_[0] = kAnnounce;
}
inline void Common_Message::clear_announce() {
  if (_internal_has_announce()) {
    if (GetArenaForAllocation() == nullptr) {
      delete messages_.announce_;
    }
    clear_has_messages();
  }
}
inline ::Announce* Common_Message::release_announce() {
  // @@protoc_insertion_point(field_release:Common_Message.announce)
  if (_internal_has_announce()) {
    clear_has_messages();
      ::Announce* temp = messages_.announce_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    messages_.announce_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Announce& Common_Message::_internal_announce() const {
  return _internal_has_announce()
      ? *messages_.announce_
      : reinterpret_cast< ::Announce&>(::_Announce_default_instance_);
}
inline const ::Announce& Common_Message::announce() const {
  // @@protoc_insertion_point(field_get:Common_Message.announce)
  return _internal_announce();
}
inline ::Announce* Common_Message::unsafe_arena_release_announce() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.announce)
  if (_internal_has_announce()) {
    clear_has_messages();
    ::Announce* temp = messages_.announce_;
    messages_.announce_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_announce(::Announce* announce) {
  clear_messages();
  if (announce) {
    set_has_announce();
    messages_.announce_ = announce;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.announce)
}
inline ::Announce* Common_Message::_internal_mutable_announce() {
  if (!_internal_has_announce()) {
    clear_messages();
    set_has_announce();
    messages_.announce_ = CreateMaybeMessage< ::Announce >(GetArenaForAllocation());
  }
  return messages_.announce_;
}
inline ::Announce* Common_Message::mutable_announce() {
  ::Announce* _msg = _internal_mutable_announce();
  // @@protoc_insertion_point(field_mutable:Common_Message.announce)
  return _msg;
}

// .Low_Level low_level = 4;
inline bool Common_Message::_internal_has_low_level() const {
  return messages_case() == kLowLevel;
}
inline bool Common_Message::has_low_level() const {
  return _internal_has_low_level();
}
inline void Common_Message::set_has_low_level() {
  _oneof_case_[0] = kLowLevel;
}
inline void Common_Message::clear_low_level() {
  if (_internal_has_low_level()) {
    if (GetArenaForAllocation() == nullptr) {
      delete messages_.low_level_;
    }
    clear_has_messages();
  }
}
inline ::Low_Level* Common_Message::release_low_level() {
  // @@protoc_insertion_point(field_release:Common_Message.low_level)
  if (_internal_has_low_level()) {
    clear_has_messages();
      ::Low_Level* temp = messages_.low_level_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    messages_.low_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Low_Level& Common_Message::_internal_low_level() const {
  return _internal_has_low_level()
      ? *messages_.low_level_
      : reinterpret_cast< ::Low_Level&>(::_Low_Level_default_instance_);
}
inline const ::Low_Level& Common_Message::low_level() const {
  // @@protoc_insertion_point(field_get:Common_Message.low_level)
  return _internal_low_level();
}
inline ::Low_Level* Common_Message::unsafe_arena_release_low_level() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.low_level)
  if (_internal_has_low_level()) {
    clear_has_messages();
    ::Low_Level* temp = messages_.low_level_;
    messages_.low_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_low_level(::Low_Level* low_level) {
  clear_messages();
  if (low_level) {
    set_has_low_level();
    messages_.low_level_ = low_level;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.low_level)
}
inline ::Low_Level* Common_Message::_internal_mutable_low_level() {
  if (!_internal_has_low_level()) {
    clear_messages();
    set_has_low_level();
    messages_.low_level_ = CreateMaybeMessage< ::Low_Level >(GetArenaForAllocation());
  }
  return messages_.low_level_;
}
inline ::Low_Level* Common_Message::mutable_low_level() {
  ::Low_Level* _msg = _internal_mutable_low_level();
  // @@protoc_insertion_point(field_mutable:Common_Message.low_level)
  return _msg;
}

// .Lobby lobby = 5;
inline bool Common_Message::_internal_has_lobby() const {
  return messages_case() == kLobby;
}
inline bool Common_Message::has_lobby() const {
  return _internal_has_lobby();
}
inline void Common_Message::set_has_lobby() {
  _oneof_case_[0] = kLobby;
}
inline void Common_Message::clear_lobby() {
  if (_internal_has_lobby()) {
    if (GetArenaForAllocation() == nullptr) {
      delete messages_.lobby_;
    }
    clear_has_messages();
  }
}
inline ::Lobby* Common_Message::release_lobby() {
  // @@protoc_insertion_point(field_release:Common_Message.lobby)
  if (_internal_has_lobby()) {
    clear_has_messages();
      ::Lobby* temp = messages_.lobby_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    messages_.lobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Lobby& Common_Message::_internal_lobby() const {
  return _internal_has_lobby()
      ? *messages_.lobby_
      : reinterpret_cast< ::Lobby&>(::_Lobby_default_instance_);
}
inline const ::Lobby& Common_Message::lobby() const {
  // @@protoc_insertion_point(field_get:Common_Message.lobby)
  return _internal_lobby();
}
inline ::Lobby* Common_Message::unsafe_arena_release_lobby() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.lobby)
  if (_internal_has_lobby()) {
    clear_has_messages();
    ::Lobby* temp = messages_.lobby_;
    messages_.lobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_lobby(::Lobby* lobby) {
  clear_messages();
  if (lobby) {
    set_has_lobby();
    messages_.lobby_ = lobby;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.lobby)
}
inline ::Lobby* Common_Message::_internal_mutable_lobby() {
  if (!_internal_has_lobby()) {
    clear_messages();
    set_has_lobby();
    messages_.lobby_ = CreateMaybeMessage< ::Lobby >(GetArenaForAllocation());
  }
  return messages_.lobby_;
}
inline ::Lobby* Common_Message::mutable_lobby() {
  ::Lobby* _msg = _internal_mutable_lobby();
  // @@protoc_insertion_point(field_mutable:Common_Message.lobby)
  return _msg;
}

// .Lobby_Messages lobby_messages = 6;
inline bool Common_Message::_internal_has_lobby_messages() const {
  return messages_case() == kLobbyMessages;
}
inline bool Common_Message::has_lobby_messages() const {
  return _internal_has_lobby_messages();
}
inline void Common_Message::set_has_lobby_messages() {
  _oneof_case_[0] = kLobbyMessages;
}
inline void Common_Message::clear_lobby_messages() {
  if (_internal_has_lobby_messages()) {
    if (GetArenaForAllocation() == nullptr) {
      delete messages_.lobby_messages_;
    }
    clear_has_messages();
  }
}
inline ::Lobby_Messages* Common_Message::release_lobby_messages() {
  // @@protoc_insertion_point(field_release:Common_Message.lobby_messages)
  if (_internal_has_lobby_messages()) {
    clear_has_messages();
      ::Lobby_Messages* temp = messages_.lobby_messages_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    messages_.lobby_messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Lobby_Messages& Common_Message::_internal_lobby_messages() const {
  return _internal_has_lobby_messages()
      ? *messages_.lobby_messages_
      : reinterpret_cast< ::Lobby_Messages&>(::_Lobby_Messages_default_instance_);
}
inline const ::Lobby_Messages& Common_Message::lobby_messages() const {
  // @@protoc_insertion_point(field_get:Common_Message.lobby_messages)
  return _internal_lobby_messages();
}
inline ::Lobby_Messages* Common_Message::unsafe_arena_release_lobby_messages() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.lobby_messages)
  if (_internal_has_lobby_messages()) {
    clear_has_messages();
    ::Lobby_Messages* temp = messages_.lobby_messages_;
    messages_.lobby_messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_lobby_messages(::Lobby_Messages* lobby_messages) {
  clear_messages();
  if (lobby_messages) {
    set_has_lobby_messages();
    messages_.lobby_messages_ = lobby_messages;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.lobby_messages)
}
inline ::Lobby_Messages* Common_Message::_internal_mutable_lobby_messages() {
  if (!_internal_has_lobby_messages()) {
    clear_messages();
    set_has_lobby_messages();
    messages_.lobby_messages_ = CreateMaybeMessage< ::Lobby_Messages >(GetArenaForAllocation());
  }
  return messages_.lobby_messages_;
}
inline ::Lobby_Messages* Common_Message::mutable_lobby_messages() {
  ::Lobby_Messages* _msg = _internal_mutable_lobby_messages();
  // @@protoc_insertion_point(field_mutable:Common_Message.lobby_messages)
  return _msg;
}

// .Network network = 7;
inline bool Common_Message::_internal_has_network() const {
  return messages_case() == kNetwork;
}
inline bool Common_Message::has_network() const {
  return _internal_has_network();
}
inline void Common_Message::set_has_network() {
  _oneof_case_[0] = kNetwork;
}
inline void Common_Message::clear_network() {
  if (_internal_has_network()) {
    if (GetArenaForAllocation() == nullptr) {
      delete messages_.network_;
    }
    clear_has_messages();
  }
}
inline ::Network* Common_Message::release_network() {
  // @@protoc_insertion_point(field_release:Common_Message.network)
  if (_internal_has_network()) {
    clear_has_messages();
      ::Network* temp = messages_.network_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    messages_.network_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Network& Common_Message::_internal_network() const {
  return _internal_has_network()
      ? *messages_.network_
      : reinterpret_cast< ::Network&>(::_Network_default_instance_);
}
inline const ::Network& Common_Message::network() const {
  // @@protoc_insertion_point(field_get:Common_Message.network)
  return _internal_network();
}
inline ::Network* Common_Message::unsafe_arena_release_network() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.network)
  if (_internal_has_network()) {
    clear_has_messages();
    ::Network* temp = messages_.network_;
    messages_.network_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_network(::Network* network) {
  clear_messages();
  if (network) {
    set_has_network();
    messages_.network_ = network;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.network)
}
inline ::Network* Common_Message::_internal_mutable_network() {
  if (!_internal_has_network()) {
    clear_messages();
    set_has_network();
    messages_.network_ = CreateMaybeMessage< ::Network >(GetArenaForAllocation());
  }
  return messages_.network_;
}
inline ::Network* Common_Message::mutable_network() {
  ::Network* _msg = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:Common_Message.network)
  return _msg;
}

// .Gameserver gameserver = 8;
inline bool Common_Message::_internal_has_gameserver() const {
  return messages_case() == kGameserver;
}
inline bool Common_Message::has_gameserver() const {
  return _internal_has_gameserver();
}
inline void Common_Message::set_has_gameserver() {
  _oneof_case_[0] = kGameserver;
}
inline void Common_Message::clear_gameserver() {
  if (_internal_has_gameserver()) {
    if (GetArenaForAllocation() == nullptr) {
      delete messages_.gameserver_;
    }
    clear_has_messages();
  }
}
inline ::Gameserver* Common_Message::release_gameserver() {
  // @@protoc_insertion_point(field_release:Common_Message.gameserver)
  if (_internal_has_gameserver()) {
    clear_has_messages();
      ::Gameserver* temp = messages_.gameserver_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    messages_.gameserver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Gameserver& Common_Message::_internal_gameserver() const {
  return _internal_has_gameserver()
      ? *messages_.gameserver_
      : reinterpret_cast< ::Gameserver&>(::_Gameserver_default_instance_);
}
inline const ::Gameserver& Common_Message::gameserver() const {
  // @@protoc_insertion_point(field_get:Common_Message.gameserver)
  return _internal_gameserver();
}
inline ::Gameserver* Common_Message::unsafe_arena_release_gameserver() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.gameserver)
  if (_internal_has_gameserver()) {
    clear_has_messages();
    ::Gameserver* temp = messages_.gameserver_;
    messages_.gameserver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_gameserver(::Gameserver* gameserver) {
  clear_messages();
  if (gameserver) {
    set_has_gameserver();
    messages_.gameserver_ = gameserver;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.gameserver)
}
inline ::Gameserver* Common_Message::_internal_mutable_gameserver() {
  if (!_internal_has_gameserver()) {
    clear_messages();
    set_has_gameserver();
    messages_.gameserver_ = CreateMaybeMessage< ::Gameserver >(GetArenaForAllocation());
  }
  return messages_.gameserver_;
}
inline ::Gameserver* Common_Message::mutable_gameserver() {
  ::Gameserver* _msg = _internal_mutable_gameserver();
  // @@protoc_insertion_point(field_mutable:Common_Message.gameserver)
  return _msg;
}

// .Friend friend = 9;
inline bool Common_Message::_internal_has_friend_() const {
  return messages_case() == kFriend;
}
inline bool Common_Message::has_friend_() const {
  return _internal_has_friend_();
}
inline void Common_Message::set_has_friend_() {
  _oneof_case_[0] = kFriend;
}
inline void Common_Message::clear_friend_() {
  if (_internal_has_friend_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete messages_.friend__;
    }
    clear_has_messages();
  }
}
inline ::Friend* Common_Message::release_friend_() {
  // @@protoc_insertion_point(field_release:Common_Message.friend)
  if (_internal_has_friend_()) {
    clear_has_messages();
      ::Friend* temp = messages_.friend__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    messages_.friend__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Friend& Common_Message::_internal_friend_() const {
  return _internal_has_friend_()
      ? *messages_.friend__
      : reinterpret_cast< ::Friend&>(::_Friend_default_instance_);
}
inline const ::Friend& Common_Message::friend_() const {
  // @@protoc_insertion_point(field_get:Common_Message.friend)
  return _internal_friend_();
}
inline ::Friend* Common_Message::unsafe_arena_release_friend_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.friend)
  if (_internal_has_friend_()) {
    clear_has_messages();
    ::Friend* temp = messages_.friend__;
    messages_.friend__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_friend_(::Friend* friend_) {
  clear_messages();
  if (friend_) {
    set_has_friend_();
    messages_.friend__ = friend_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.friend)
}
inline ::Friend* Common_Message::_internal_mutable_friend_() {
  if (!_internal_has_friend_()) {
    clear_messages();
    set_has_friend_();
    messages_.friend__ = CreateMaybeMessage< ::Friend >(GetArenaForAllocation());
  }
  return messages_.friend__;
}
inline ::Friend* Common_Message::mutable_friend_() {
  ::Friend* _msg = _internal_mutable_friend_();
  // @@protoc_insertion_point(field_mutable:Common_Message.friend)
  return _msg;
}

// .Auth_Ticket auth_ticket = 10;
inline bool Common_Message::_internal_has_auth_ticket() const {
  return messages_case() == kAuthTicket;
}
inline bool Common_Message::has_auth_ticket() const {
  return _internal_has_auth_ticket();
}
inline void Common_Message::set_has_auth_ticket() {
  _oneof_case_[0] = kAuthTicket;
}
inline void Common_Message::clear_auth_ticket() {
  if (_internal_has_auth_ticket()) {
    if (GetArenaForAllocation() == nullptr) {
      delete messages_.auth_ticket_;
    }
    clear_has_messages();
  }
}
inline ::Auth_Ticket* Common_Message::release_auth_ticket() {
  // @@protoc_insertion_point(field_release:Common_Message.auth_ticket)
  if (_internal_has_auth_ticket()) {
    clear_has_messages();
      ::Auth_Ticket* temp = messages_.auth_ticket_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    messages_.auth_ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Auth_Ticket& Common_Message::_internal_auth_ticket() const {
  return _internal_has_auth_ticket()
      ? *messages_.auth_ticket_
      : reinterpret_cast< ::Auth_Ticket&>(::_Auth_Ticket_default_instance_);
}
inline const ::Auth_Ticket& Common_Message::auth_ticket() const {
  // @@protoc_insertion_point(field_get:Common_Message.auth_ticket)
  return _internal_auth_ticket();
}
inline ::Auth_Ticket* Common_Message::unsafe_arena_release_auth_ticket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.auth_ticket)
  if (_internal_has_auth_ticket()) {
    clear_has_messages();
    ::Auth_Ticket* temp = messages_.auth_ticket_;
    messages_.auth_ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_auth_ticket(::Auth_Ticket* auth_ticket) {
  clear_messages();
  if (auth_ticket) {
    set_has_auth_ticket();
    messages_.auth_ticket_ = auth_ticket;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.auth_ticket)
}
inline ::Auth_Ticket* Common_Message::_internal_mutable_auth_ticket() {
  if (!_internal_has_auth_ticket()) {
    clear_messages();
    set_has_auth_ticket();
    messages_.auth_ticket_ = CreateMaybeMessage< ::Auth_Ticket >(GetArenaForAllocation());
  }
  return messages_.auth_ticket_;
}
inline ::Auth_Ticket* Common_Message::mutable_auth_ticket() {
  ::Auth_Ticket* _msg = _internal_mutable_auth_ticket();
  // @@protoc_insertion_point(field_mutable:Common_Message.auth_ticket)
  return _msg;
}

// .Friend_Messages friend_messages = 11;
inline bool Common_Message::_internal_has_friend_messages() const {
  return messages_case() == kFriendMessages;
}
inline bool Common_Message::has_friend_messages() const {
  return _internal_has_friend_messages();
}
inline void Common_Message::set_has_friend_messages() {
  _oneof_case_[0] = kFriendMessages;
}
inline void Common_Message::clear_friend_messages() {
  if (_internal_has_friend_messages()) {
    if (GetArenaForAllocation() == nullptr) {
      delete messages_.friend_messages_;
    }
    clear_has_messages();
  }
}
inline ::Friend_Messages* Common_Message::release_friend_messages() {
  // @@protoc_insertion_point(field_release:Common_Message.friend_messages)
  if (_internal_has_friend_messages()) {
    clear_has_messages();
      ::Friend_Messages* temp = messages_.friend_messages_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    messages_.friend_messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Friend_Messages& Common_Message::_internal_friend_messages() const {
  return _internal_has_friend_messages()
      ? *messages_.friend_messages_
      : reinterpret_cast< ::Friend_Messages&>(::_Friend_Messages_default_instance_);
}
inline const ::Friend_Messages& Common_Message::friend_messages() const {
  // @@protoc_insertion_point(field_get:Common_Message.friend_messages)
  return _internal_friend_messages();
}
inline ::Friend_Messages* Common_Message::unsafe_arena_release_friend_messages() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.friend_messages)
  if (_internal_has_friend_messages()) {
    clear_has_messages();
    ::Friend_Messages* temp = messages_.friend_messages_;
    messages_.friend_messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_friend_messages(::Friend_Messages* friend_messages) {
  clear_messages();
  if (friend_messages) {
    set_has_friend_messages();
    messages_.friend_messages_ = friend_messages;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.friend_messages)
}
inline ::Friend_Messages* Common_Message::_internal_mutable_friend_messages() {
  if (!_internal_has_friend_messages()) {
    clear_messages();
    set_has_friend_messages();
    messages_.friend_messages_ = CreateMaybeMessage< ::Friend_Messages >(GetArenaForAllocation());
  }
  return messages_.friend_messages_;
}
inline ::Friend_Messages* Common_Message::mutable_friend_messages() {
  ::Friend_Messages* _msg = _internal_mutable_friend_messages();
  // @@protoc_insertion_point(field_mutable:Common_Message.friend_messages)
  return _msg;
}

// .Network_Old network_old = 12;
inline bool Common_Message::_internal_has_network_old() const {
  return messages_case() == kNetworkOld;
}
inline bool Common_Message::has_network_old() const {
  return _internal_has_network_old();
}
inline void Common_Message::set_has_network_old() {
  _oneof_case_[0] = kNetworkOld;
}
inline void Common_Message::clear_network_old() {
  if (_internal_has_network_old()) {
    if (GetArenaForAllocation() == nullptr) {
      delete messages_.network_old_;
    }
    clear_has_messages();
  }
}
inline ::Network_Old* Common_Message::release_network_old() {
  // @@protoc_insertion_point(field_release:Common_Message.network_old)
  if (_internal_has_network_old()) {
    clear_has_messages();
      ::Network_Old* temp = messages_.network_old_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    messages_.network_old_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Network_Old& Common_Message::_internal_network_old() const {
  return _internal_has_network_old()
      ? *messages_.network_old_
      : reinterpret_cast< ::Network_Old&>(::_Network_Old_default_instance_);
}
inline const ::Network_Old& Common_Message::network_old() const {
  // @@protoc_insertion_point(field_get:Common_Message.network_old)
  return _internal_network_old();
}
inline ::Network_Old* Common_Message::unsafe_arena_release_network_old() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.network_old)
  if (_internal_has_network_old()) {
    clear_has_messages();
    ::Network_Old* temp = messages_.network_old_;
    messages_.network_old_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_network_old(::Network_Old* network_old) {
  clear_messages();
  if (network_old) {
    set_has_network_old();
    messages_.network_old_ = network_old;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.network_old)
}
inline ::Network_Old* Common_Message::_internal_mutable_network_old() {
  if (!_internal_has_network_old()) {
    clear_messages();
    set_has_network_old();
    messages_.network_old_ = CreateMaybeMessage< ::Network_Old >(GetArenaForAllocation());
  }
  return messages_.network_old_;
}
inline ::Network_Old* Common_Message::mutable_network_old() {
  ::Network_Old* _msg = _internal_mutable_network_old();
  // @@protoc_insertion_point(field_mutable:Common_Message.network_old)
  return _msg;
}

// .Networking_Sockets networking_sockets = 13;
inline bool Common_Message::_internal_has_networking_sockets() const {
  return messages_case() == kNetworkingSockets;
}
inline bool Common_Message::has_networking_sockets() const {
  return _internal_has_networking_sockets();
}
inline void Common_Message::set_has_networking_sockets() {
  _oneof_case_[0] = kNetworkingSockets;
}
inline void Common_Message::clear_networking_sockets() {
  if (_internal_has_networking_sockets()) {
    if (GetArenaForAllocation() == nullptr) {
      delete messages_.networking_sockets_;
    }
    clear_has_messages();
  }
}
inline ::Networking_Sockets* Common_Message::release_networking_sockets() {
  // @@protoc_insertion_point(field_release:Common_Message.networking_sockets)
  if (_internal_has_networking_sockets()) {
    clear_has_messages();
      ::Networking_Sockets* temp = messages_.networking_sockets_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    messages_.networking_sockets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Networking_Sockets& Common_Message::_internal_networking_sockets() const {
  return _internal_has_networking_sockets()
      ? *messages_.networking_sockets_
      : reinterpret_cast< ::Networking_Sockets&>(::_Networking_Sockets_default_instance_);
}
inline const ::Networking_Sockets& Common_Message::networking_sockets() const {
  // @@protoc_insertion_point(field_get:Common_Message.networking_sockets)
  return _internal_networking_sockets();
}
inline ::Networking_Sockets* Common_Message::unsafe_arena_release_networking_sockets() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.networking_sockets)
  if (_internal_has_networking_sockets()) {
    clear_has_messages();
    ::Networking_Sockets* temp = messages_.networking_sockets_;
    messages_.networking_sockets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_networking_sockets(::Networking_Sockets* networking_sockets) {
  clear_messages();
  if (networking_sockets) {
    set_has_networking_sockets();
    messages_.networking_sockets_ = networking_sockets;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.networking_sockets)
}
inline ::Networking_Sockets* Common_Message::_internal_mutable_networking_sockets() {
  if (!_internal_has_networking_sockets()) {
    clear_messages();
    set_has_networking_sockets();
    messages_.networking_sockets_ = CreateMaybeMessage< ::Networking_Sockets >(GetArenaForAllocation());
  }
  return messages_.networking_sockets_;
}
inline ::Networking_Sockets* Common_Message::mutable_networking_sockets() {
  ::Networking_Sockets* _msg = _internal_mutable_networking_sockets();
  // @@protoc_insertion_point(field_mutable:Common_Message.networking_sockets)
  return _msg;
}

// uint32 source_ip = 128;
inline void Common_Message::clear_source_ip() {
  source_ip_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Common_Message::_internal_source_ip() const {
  return source_ip_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Common_Message::source_ip() const {
  // @@protoc_insertion_point(field_get:Common_Message.source_ip)
  return _internal_source_ip();
}
inline void Common_Message::_internal_set_source_ip(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  source_ip_ = value;
}
inline void Common_Message::set_source_ip(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_source_ip(value);
  // @@protoc_insertion_point(field_set:Common_Message.source_ip)
}

// uint32 source_port = 129;
inline void Common_Message::clear_source_port() {
  source_port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Common_Message::_internal_source_port() const {
  return source_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Common_Message::source_port() const {
  // @@protoc_insertion_point(field_get:Common_Message.source_port)
  return _internal_source_port();
}
inline void Common_Message::_internal_set_source_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  source_port_ = value;
}
inline void Common_Message::set_source_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_source_port(value);
  // @@protoc_insertion_point(field_set:Common_Message.source_port)
}

inline bool Common_Message::has_messages() const {
  return messages_case() != MESSAGES_NOT_SET;
}
inline void Common_Message::clear_has_messages() {
  _oneof_case_[0] = MESSAGES_NOT_SET;
}
inline Common_Message::MessagesCase Common_Message::messages_case() const {
  return Common_Message::MessagesCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Announce_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Lobby_Messages_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Low_Level_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Network_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Network_Old_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Networking_Sockets_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Auth_Ticket_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Friend_Messages_Types> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_net_2eproto
